
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>celerity-provider-aws: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/two-hundred/celerity-provider-aws/main.go (0.0%)</option>
				
				<option value="file1">github.com/two-hundred/celerity-provider-aws/provider/config_validation.go (0.0%)</option>
				
				<option value="file2">github.com/two-hundred/celerity-provider-aws/provider/provider.go (0.0%)</option>
				
				<option value="file3">github.com/two-hundred/celerity-provider-aws/services/lambda/lambda_function_resource.go (0.0%)</option>
				
				<option value="file4">github.com/two-hundred/celerity-provider-aws/services/lambda/lambda_function_resource_get_external_state.go (0.0%)</option>
				
				<option value="file5">github.com/two-hundred/celerity-provider-aws/services/lambda/lambda_function_resource_schema.go (0.0%)</option>
				
				<option value="file6">github.com/two-hundred/celerity-provider-aws/services/lambda/lambda_service.go (0.0%)</option>
				
				<option value="file7">github.com/two-hundred/celerity-provider-aws/utils/aws_config.go (73.3%)</option>
				
				<option value="file8">github.com/two-hundred/celerity-provider-aws/utils/aws_config_store.go (96.6%)</option>
				
				<option value="file9">github.com/two-hundred/celerity-provider-aws/utils/conversion.go (0.0%)</option>
				
				<option value="file10">github.com/two-hundred/celerity-provider-aws/utils/diagnostics.go (0.0%)</option>
				
				<option value="file11">github.com/two-hundred/celerity-provider-aws/utils/services.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "embed"
        "fmt"
        "log"
        "os"

        "github.com/two-hundred/celerity-provider-aws/provider"
        "github.com/two-hundred/celerity-provider-aws/services/lambda"
        "github.com/two-hundred/celerity-provider-aws/utils"
        "github.com/two-hundred/celerity/libs/plugin-framework/plugin"
        "github.com/two-hundred/celerity/libs/plugin-framework/pluginservicev1"
        "github.com/two-hundred/celerity/libs/plugin-framework/sdk/pluginutils"
        "github.com/two-hundred/celerity/libs/plugin-framework/sdk/providerv1"
)

//go:embed provider_description.md
var embedded embed.FS

func main() <span class="cov0" title="0">{
        serviceClient, closeService, err := pluginservicev1.NewEnvServiceClient()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err.Error())
        }</span>
        <span class="cov0" title="0">defer closeService()

        hostInfoContainer := pluginutils.NewHostInfoContainer()
        providerServer := providerv1.NewProviderPlugin(
                provider.NewProvider(
                        lambda.NewService,
                        utils.NewAWSConfigStore(
                                os.Environ(),
                                utils.AWSConfigFromProviderContext,
                                &amp;utils.DefaultAWSConfigLoader{},
                        ),
                ),
                hostInfoContainer,
                serviceClient,
        )

        providerDescription, _ := embedded.ReadFile("provider_description.md")
        config := plugin.ServePluginConfiguration{
                ID: "two-hundred/aws",
                PluginMetadata: &amp;pluginservicev1.PluginMetadata{
                        PluginVersion:        "1.0.0",
                        DisplayName:          "AWS",
                        FormattedDescription: string(providerDescription),
                        RepositoryUrl:        "https://github.com/two-hundred/celerity-provider-aws",
                        Author:               "Two Hundred",
                },
                ProtocolVersion: "1.0",
        }

        fmt.Println("Starting Celerity AWS Provider Plugin Server...")
        close, err := plugin.ServeProviderV1(
                context.Background(),
                providerServer,
                serviceClient,
                hostInfoContainer,
                config,
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err.Error())
        }</span>
        <span class="cov0" title="0">pluginutils.WaitForShutdown(close)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package provider

import (
        "fmt"
        "regexp"
        "time"

        "github.com/aws/aws-sdk-go-v2/aws/arn"
        "github.com/two-hundred/celerity/libs/blueprint/core"
        "github.com/two-hundred/celerity/libs/plugin-framework/sdk/validation"
)

func validateAssumeRoleDuration(
        key string,
        value *core.ScalarValue,
        pluginConfig core.PluginConfig,
) []*core.Diagnostic <span class="cov0" title="0">{
        stringVal := core.StringValueFromScalar(value)
        duration, err := time.ParseDuration(stringVal)
        if err != nil </span><span class="cov0" title="0">{
                return []*core.Diagnostic{
                        {
                                Level: core.DiagnosticLevelError,
                                Message: fmt.Sprintf(
                                        "Invalid duration %q for field %q: %s",
                                        stringVal, key, err.Error(),
                                ),
                        },
                }
        }</span>

        <span class="cov0" title="0">if duration.Minutes() &lt; 15 || duration.Hours() &gt; 12 </span><span class="cov0" title="0">{
                return []*core.Diagnostic{
                        {
                                Level: core.DiagnosticLevelError,
                                Message: fmt.Sprintf(
                                        "Duration %q for field %q must be between 15 minutes and 12 hours",
                                        stringVal, key,
                                ),
                        },
                }
        }</span>

        <span class="cov0" title="0">return []*core.Diagnostic{}</span>
}

var partitionRegexp = regexp.MustCompile(`^aws(-[a-z]+)*$`)
var regionRegexp = regexp.MustCompile(`^[a-z]{2}(-[a-z]+)+-\d{1,2}$`)
var accountIDRegexp = regexp.MustCompile(
        `^(aws|aws-managed|third-party|aws-marketplace|\d{12}|cw.{10})$`,
)

func validateARN(
        key string,
        value *core.ScalarValue,
        pluginConfig core.PluginConfig,
) []*core.Diagnostic <span class="cov0" title="0">{
        diagnostics := []*core.Diagnostic{}

        stringVal := core.StringValueFromScalar(value)
        parsedARN, err := arn.Parse(stringVal)
        if err != nil </span><span class="cov0" title="0">{
                return []*core.Diagnostic{
                        {
                                Level: core.DiagnosticLevelError,
                                Message: fmt.Sprintf(
                                        "Invalid ARN %q for field %q: %s",
                                        stringVal, key, err.Error(),
                                ),
                        },
                }
        }</span>

        <span class="cov0" title="0">if parsedARN.Partition == "" </span><span class="cov0" title="0">{
                diagnostics = append(diagnostics, &amp;core.Diagnostic{
                        Level: core.DiagnosticLevelError,
                        Message: fmt.Sprintf(
                                "ARN %q for field %q is missing a partition value",
                                stringVal,
                                key,
                        ),
                })
        }</span> else<span class="cov0" title="0"> if !partitionRegexp.MatchString(parsedARN.Partition) </span><span class="cov0" title="0">{
                diagnostics = append(diagnostics, &amp;core.Diagnostic{
                        Level: core.DiagnosticLevelError,
                        Message: fmt.Sprintf(
                                "ARN %q for field %q has an invalid partition value: %s",
                                stringVal, key, parsedARN.Partition,
                        ),
                })
        }</span>

        <span class="cov0" title="0">if parsedARN.Region != "" &amp;&amp; !regionRegexp.MatchString(parsedARN.Region) </span><span class="cov0" title="0">{
                diagnostics = append(diagnostics, &amp;core.Diagnostic{
                        Level: core.DiagnosticLevelError,
                        Message: fmt.Sprintf(
                                "ARN %q for field %q has an invalid region value: %s",
                                stringVal, key, parsedARN.Region,
                        ),
                })
        }</span>

        <span class="cov0" title="0">if parsedARN.AccountID != "" &amp;&amp;
                !accountIDRegexp.MatchString(parsedARN.AccountID) </span><span class="cov0" title="0">{
                diagnostics = append(diagnostics, &amp;core.Diagnostic{
                        Level: core.DiagnosticLevelError,
                        Message: fmt.Sprintf(
                                "ARN %q for field %q has an invalid account ID: %s",
                                stringVal, key, parsedARN.AccountID,
                        ),
                })
        }</span>

        <span class="cov0" title="0">if parsedARN.Resource == "" </span><span class="cov0" title="0">{
                diagnostics = append(diagnostics, &amp;core.Diagnostic{
                        Level: core.DiagnosticLevelError,
                        Message: fmt.Sprintf(
                                "ARN %q for field %q is missing a resource value",
                                stringVal, key,
                        ),
                })
        }</span>

        <span class="cov0" title="0">return diagnostics</span>
}

var validateAssumeRoleSessionName = validation.WrapForPluginConfig(
        validation.AllOf(
                validation.StringLengthRange(2, 64),
                validation.StringMatchesPattern(
                        regexp.MustCompile(`[\w+=,.@\-]*`),
                ),
        ),
)

var validateAssumeRoleSourceIdentity = validation.WrapForPluginConfig(
        validation.AllOf(
                validation.StringLengthRange(2, 64),
                validation.StringMatchesPattern(
                        regexp.MustCompile(`[\w+=,.@\-]*`),
                ),
        ),
)
</pre>
		
		<pre class="file" id="file2" style="display: none">package provider

import (
        "regexp"

        "github.com/two-hundred/celerity-provider-aws/services/lambda"
        "github.com/two-hundred/celerity-provider-aws/types"
        "github.com/two-hundred/celerity-provider-aws/utils"
        "github.com/two-hundred/celerity/libs/blueprint/core"
        "github.com/two-hundred/celerity/libs/blueprint/provider"
        "github.com/two-hundred/celerity/libs/plugin-framework/sdk/providerv1"
        "github.com/two-hundred/celerity/libs/plugin-framework/sdk/validation"
)

func NewProvider(
        lambdaServiceFactory types.ServiceFactory[lambda.Service],
        awsConfigStore *utils.AWSConfigStore,
) provider.Provider <span class="cov0" title="0">{
        return &amp;providerv1.ProviderPluginDefinition{
                ProviderNamespace:        "aws",
                ProviderConfigDefinition: providerConfigDefinition(),
                Resources: map[string]provider.Resource{
                        "aws/lambda/function": lambda.FunctionResource(
                                lambdaServiceFactory,
                                awsConfigStore,
                        ),
                },
                DataSources:         map[string]provider.DataSource{},
                Links:               map[string]provider.Link{},
                CustomVariableTypes: map[string]provider.CustomVariableType{},
                Functions:           map[string]provider.Function{},
        }
}</span>

func providerConfigDefinition() *core.ConfigDefinition <span class="cov0" title="0">{
        return &amp;core.ConfigDefinition{
                Fields: map[string]*core.ConfigFieldDefinition{
                        "accessKeyId": {
                                Type:  core.ScalarTypeString,
                                Label: "Access Key ID",
                                Description: "The access key ID for API operations. " +
                                        "This can be retrieved from the 'Security &amp; Credentials' section of the AWS console.",
                        },
                        "secretAccessKey": {
                                Type:  core.ScalarTypeString,
                                Label: "Secret Access Key",
                                Description: "The secret access key for API operations. " +
                                        "This can be retrieved from the 'Security &amp; Credentials' section of the AWS console.",
                                Secret: true,
                        },
                        "customCABundle": {
                                Type:  core.ScalarTypeString,
                                Label: "Custom CA Bundle",
                                Description: "The path to a custom CA bundle file to use for " +
                                        "TLS connections to AWS services. This can also be " +
                                        "configured using the `AWS_CA_BUNDLE` environment variable.",
                        },
                        "ec2MetadataServiceEndpoint": {
                                Type:  core.ScalarTypeString,
                                Label: "EC2 Metadata Service Endpoint",
                                Description: "The address of the EC2 metadata service endpoint to use. " +
                                        "This can also be configured using the `AWS_EC2_METADATA_SERVICE_ENDPOINT` environment variable.",
                        },
                        "ec2MetadataServiceEndpointMode": {
                                Type:  core.ScalarTypeString,
                                Label: "EC2 Metadata Service Endpoint Mode",
                                Description: "The protocol to use for the EC2 metadata service endpoint. " +
                                        "This can also be configured using the `AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE` environment variable.",
                                AllowedValues: []*core.ScalarValue{
                                        core.ScalarFromString("IPv4"),
                                        core.ScalarFromString("IPv6"),
                                },
                        },
                        "endpoint.&lt;serviceOrAlias&gt;": {
                                Type:  core.ScalarTypeString,
                                Label: "Custom Service Endpoints",
                                Description: "The addresses to use to override the default service endpoint URL. " +
                                        "&lt;serviceOrAlias&gt; must match a valid service string or an alias for a service. " +
                                        "The following is a list of all the supported services and their aliases:\n" +
                                        utils.AWSServiceList(),
                        },
                        "httpProxy": {
                                Type:  core.ScalarTypeString,
                                Label: "HTTP Proxy",
                                Description: "URL of a proxy to use for HTTP requests when accessing the AWS API. " +
                                        "This can also be set using the `HTTP_PROXY` environment variable.",
                        },
                        "httpsProxy": {
                                Type:  core.ScalarTypeString,
                                Label: "HTTPS Proxy",
                                Description: "URL of a proxy to use for HTTPS requests when accessing the AWS API. " +
                                        "This can also be set using the `HTTPS_PROXY` environment variable.",
                        },
                        "insecure": {
                                Type:  core.ScalarTypeBool,
                                Label: "Insecure",
                                Description: "If true, the provider will not verify the TLS " +
                                        "certificate of the AWS API. If omitted, the default value is `false`.",
                        },
                        "maxRetries": {
                                Type:  core.ScalarTypeInteger,
                                Label: "Max Retries",
                                Description: "The maximum number of retries to attempt when a request to an AWS API fails. " +
                                        "If not set, the AWS SDK defaults will be used.",
                        },
                        "profile": {
                                Type:  core.ScalarTypeString,
                                Label: "Profile",
                                Description: "The name of the AWS profile to use for API operations. If not set, " +
                                        "the default profile created with `aws configure` will be used.",
                        },
                        "region": {
                                Type:  core.ScalarTypeString,
                                Label: "Region",
                                Description: "The AWS region to use for API operations. If not set, " +
                                        "the default region will be used based on the environment.",
                        },
                        "retryMode": {
                                Type:  core.ScalarTypeString,
                                Label: "Retry Mode",
                                Description: "Determines how retries are attempted. " +
                                        "Valid values are `standard` and `adaptive`. " +
                                        "This can also be configured using the `AWS_RETRY_MODE` environment variable.",
                                AllowedValues: []*core.ScalarValue{
                                        core.ScalarFromString("standard"),
                                        core.ScalarFromString("adaptive"),
                                },
                        },
                        "s3UsePathStyle": {
                                Type:  core.ScalarTypeBool,
                                Label: "S3 Use Path Style",
                                Description: "If true, the provider will use the path-style addressing " +
                                        "for S3 URLs. If false, the virtual hosted-style addressing will be used.\n" +
                                        "Path style addresses are of the form https://s3.amazonaws.com/&lt;bucket&gt;/&lt;key&gt;, " +
                                        "while virtual hosted-style addresses are of the form https://&lt;bucket&gt;.s3.amazonaws.com/&lt;key&gt;.",
                        },
                        "sharedConfigFiles": {
                                Type:         core.ScalarTypeString,
                                Label:        "Shared Config Files",
                                Description:  "A comma-separated list of paths to shared AWS config files to use for API operations.",
                                DefaultValue: core.ScalarFromString("~/.aws/config"),
                        },
                        "sharedCredentialsFiles": {
                                Type:         core.ScalarTypeString,
                                Label:        "Shared Credentials Files",
                                Description:  "A comma-separated list of paths to shared AWS credentials files to use for API operations.",
                                DefaultValue: core.ScalarFromString("~/.aws/credentials"),
                        },
                        "sessionToken": {
                                Type:        core.ScalarTypeString,
                                Label:       "Session Token",
                                Description: "The session token. This is only required if you are using temporary security credentials.",
                                Secret:      true,
                        },
                        "useDualStackEndpoint": {
                                Type:        core.ScalarTypeBool,
                                Label:       "Use Dual Stack Endpoint",
                                Description: "If true, the provider will resolve and endpoint with DualStack capability.",
                        },
                        "useFIPSEndpoint": {
                                Type:        core.ScalarTypeBool,
                                Label:       "Use FIPS Endpoint",
                                Description: "If true, the provider will resolve and endpoint with FIPS capability.",
                        },
                        "assumeRole.duration": {
                                Type:  core.ScalarTypeString,
                                Label: "Assume Role Duration",
                                Description: "The duration between 15 minutes and 12 hours for which the assumed role session will be valid. " +
                                        "Valid units of time are ns, us (or μs), ms, s, m, h.",
                                DefaultValue: core.ScalarFromString("1h"),
                                Examples: []*core.ScalarValue{
                                        core.ScalarFromString("15m"),
                                        core.ScalarFromString("1h"),
                                        core.ScalarFromString("12h"),
                                },
                                ValidateFunc: validateAssumeRoleDuration,
                        },
                        "assumeRole.externalId": {
                                Type:  core.ScalarTypeString,
                                Label: "Assume Role External ID",
                                Description: "An optional unique identifier that may be required " +
                                        "when assuming a role in another account.",
                                ValidateFunc: validation.WrapForPluginConfig(
                                        validation.AllOf(
                                                validation.StringLengthRange(2, 1224),
                                                validation.StringMatchesPattern(
                                                        regexp.MustCompile(`[\w+=,.@:\/\-]*`),
                                                ),
                                        ),
                                ),
                        },
                        "assumeRole.roleArn": {
                                Type:         core.ScalarTypeString,
                                Label:        "Assume Role ARN",
                                Description:  "The ARN of the IAM role to assume for API operations.",
                                ValidateFunc: validateARN,
                        },
                        "assumeRole.policy": {
                                Type:  core.ScalarTypeString,
                                Label: "Assume Role Policy",
                                Description: "The IAM policy JSON document containing further" +
                                        " restrictions for the IAM role being assumed.",
                                ValidateFunc: validation.WrapForPluginConfig(
                                        validation.StringIsJSON(),
                                ),
                        },
                        "assumeRole.policyArns.&lt;index&gt;": {
                                Type:  core.ScalarTypeString,
                                Label: "Assume Role Policy ARNs",
                                Description: "Amazon Resource Names (ARNs) of IAM Policies " +
                                        "for further restricting permissions for the IAM Role being assumed.",
                                ValidateFunc: validateARN,
                        },
                        "assumeRole.sessionName": {
                                Type:         core.ScalarTypeString,
                                Label:        "Assume Role Session Name",
                                Description:  "A unique identifier for the assumed role session.",
                                ValidateFunc: validateAssumeRoleSessionName,
                        },
                        "assumeRole.sourceIdentity": {
                                Type:         core.ScalarTypeString,
                                Label:        "Assume Role Source Identity",
                                Description:  "Source identity defined by the principal that is assuming the role.",
                                ValidateFunc: validateAssumeRoleSourceIdentity,
                        },
                        "assumeRole.tags.&lt;tagName&gt;": {
                                Type:        core.ScalarTypeString,
                                Label:       "Assume Role Tags",
                                Description: "Tags to apply to the assumed role session.",
                        },
                        "assumeRole.transitiveTagKeys": {
                                Type:        core.ScalarTypeString,
                                Label:       "Assume Role Transitive Tag Keys",
                                Description: "A comma-separated list of tag keys to pass to any subsequent sessions.",
                        },
                        "assumeRoleWithWebIdentity.duration": {
                                Type:  core.ScalarTypeString,
                                Label: "Assume Role With Web Identity Duration",
                                Description: "The duration between 15 minutes and 12 hours for which the assumed role session will be valid. " +
                                        "Valid units of time are ns, us (or μs), ms, s, m, h.",
                                DefaultValue: core.ScalarFromString("1h"),
                                Examples: []*core.ScalarValue{
                                        core.ScalarFromString("15m"),
                                        core.ScalarFromString("1h"),
                                        core.ScalarFromString("12h"),
                                },
                                ValidateFunc: validateAssumeRoleDuration,
                        },
                        "assumeRoleWithWebIdentity.policy": {
                                Type:  core.ScalarTypeString,
                                Label: "Assume Role With Web Identity Policy",
                                Description: "The IAM policy JSON document containing further " +
                                        "restrictions for the IAM role being assumed with web identity.",
                                ValidateFunc: validation.WrapForPluginConfig(
                                        validation.StringIsJSON(),
                                ),
                        },
                        "assumeRoleWithWebIdentity.policyArns.&lt;index&gt;": {
                                Type:  core.ScalarTypeString,
                                Label: "Assume Role With Web Identity Policy ARNs",
                                Description: "Amazon Resource Names (ARNs) of IAM Policies " +
                                        "for further restricting permissions for the IAM Role being assumed with web identity.",
                                ValidateFunc: validateARN,
                        },
                        "assumeRoleWithWebIdentity.roleArn": {
                                Type:  core.ScalarTypeString,
                                Label: "Assume Role With Web Identity ARN",
                                Description: "The ARN of the IAM role to assume for API operations " +
                                        "when using web identity.",
                                ValidateFunc: validateARN,
                        },
                        "assumeRoleWithWebIdentity.sessionName": {
                                Type:  core.ScalarTypeString,
                                Label: "Assume Role With Web Identity Session Name",
                                Description: "A unique identifier for the assumed role session " +
                                        "when using web identity.",
                                ValidateFunc: validateAssumeRoleSessionName,
                        },
                        "assumeRoleWithWebIdentity.webIdentityToken": {
                                Type:  core.ScalarTypeString,
                                Label: "Assume Role With Web Identity Web Identity Token",
                                Description: "The web identity token to use when assuming the role " +
                                        "when using web identity.",
                                ValidateFunc: validation.WrapForPluginConfig(
                                        validation.StringLengthRange(4, 20000),
                                ),
                        },
                        "assumeRoleWithWebIdentity.webIdentityTokenFile": {
                                Type:  core.ScalarTypeString,
                                Label: "Assume Role With Web Identity Web Identity Token File",
                                Description: "The path to the file containing the web identity token " +
                                        "to use when assuming the role when using web identity.",
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package lambda

import (
        "context"

        providertypes "github.com/two-hundred/celerity-provider-aws/types"
        "github.com/two-hundred/celerity-provider-aws/utils"

        "github.com/aws/aws-sdk-go-v2/service/lambda"
        "github.com/aws/aws-sdk-go-v2/service/lambda/types"
        "github.com/two-hundred/celerity/libs/blueprint/core"
        "github.com/two-hundred/celerity/libs/blueprint/provider"
        "github.com/two-hundred/celerity/libs/plugin-framework/sdk/providerv1"
)

// FunctionResource returns a resource implementation for an AWS Lambda Function.
func FunctionResource(
        lambdaServiceFactory providertypes.ServiceFactory[Service],
        awsConfigStore *utils.AWSConfigStore,
) provider.Resource <span class="cov0" title="0">{
        yamlExample, _ := examples.ReadFile("examples/resources/lambda_function_yaml.md")
        jsoncExample, _ := examples.ReadFile("examples/resources/lambda_function_jsonc.md")
        yamlInlineExample, _ := examples.ReadFile("examples/resources/lambda_function_inline_yaml.md")

        lambdaFunctionActions := &amp;lambdaFunctionResourceActions{
                lambdaServiceFactory,
                awsConfigStore,
        }
        return &amp;providerv1.ResourceDefinition{
                Type:             "aws/lambda/function",
                Label:            "AWS Lambda Function",
                PlainTextSummary: "A resource for managing an AWS Lambda function.",
                FormattedDescription: "The resource type used to define a [Lambda function](https://docs.aws.amazon.com/lambda/latest/api/API_GetFunction.html) " +
                        "that is deployed to AWS.",
                Schema:  lambdaFunctionResourceSchema(),
                IDField: "arn",
                // A Lambda function will usually contain application code that will typically
                // use other resources that can be defined in a blueprint such as an S3 bucket,
                // a DynamoDB table or an SNS topic.
                CommonTerminal: false,
                FormattedExamples: []string{
                        string(yamlExample),
                        string(jsoncExample),
                        string(yamlInlineExample),
                },
                ResourceCanLinkTo:    []string{},
                GetExternalStateFunc: lambdaFunctionActions.GetExternalState,
                DeployFunc:           lambdaFunctionActions.DeployFunc,
                DestroyFunc:          lambdaFunctionActions.DestroyFunc,
                StabilisedFunc:       lambdaFunctionActions.StabilisedFunc,
        }
}</span>

type lambdaFunctionResourceActions struct {
        lambdaServiceFactory providertypes.ServiceFactory[Service]
        awsConfigStore       *utils.AWSConfigStore
}

func (l *lambdaFunctionResourceActions) getLambdaService(
        ctx context.Context,
        providerContext provider.Context,
) (Service, error) <span class="cov0" title="0">{
        awsConfig, err := l.awsConfigStore.FromProviderContext(ctx, providerContext)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return l.lambdaServiceFactory(awsConfig, providerContext), nil</span>
}

func (l *lambdaFunctionResourceActions) DeployFunc(
        ctx context.Context,
        input *provider.ResourceDeployInput,
) (*provider.ResourceDeployOutput, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (l *lambdaFunctionResourceActions) DestroyFunc(
        ctx context.Context,
        input *provider.ResourceDestroyInput,
) error <span class="cov0" title="0">{
        lambdaService, err := l.getLambdaService(ctx, input.ProviderContext)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">functionARN := core.StringValue(
                input.ResourceState.SpecData.Fields["arn"],
        )
        _, err = lambdaService.DeleteFunction(
                ctx,
                &amp;lambda.DeleteFunctionInput{
                        FunctionName: &amp;functionARN,
                },
        )

        return err</span>
}

func (l *lambdaFunctionResourceActions) StabilisedFunc(
        ctx context.Context,
        input *provider.ResourceHasStabilisedInput,
) (*provider.ResourceHasStabilisedOutput, error) <span class="cov0" title="0">{
        lambdaService, err := l.getLambdaService(ctx, input.ProviderContext)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">functionARN := core.StringValue(
                input.ResourceSpec.Fields["arn"],
        )
        functionOutput, err := lambdaService.GetFunction(
                ctx,
                &amp;lambda.GetFunctionInput{
                        FunctionName: &amp;functionARN,
                },
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">lastUpdateStatus := functionOutput.Configuration.LastUpdateStatus
        hasStabilised := lastUpdateStatus == types.LastUpdateStatusSuccessful
        return &amp;provider.ResourceHasStabilisedOutput{
                Stabilised: hasStabilised,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package lambda

import (
        "context"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/lambda"
        "github.com/aws/aws-sdk-go-v2/service/lambda/types"
        "github.com/two-hundred/celerity-provider-aws/utils"
        "github.com/two-hundred/celerity/libs/blueprint/core"
        "github.com/two-hundred/celerity/libs/blueprint/provider"
)

func (l *lambdaFunctionResourceActions) GetExternalState(
        ctx context.Context,
        input *provider.ResourceGetExternalStateInput,
) (*provider.ResourceGetExternalStateOutput, error) <span class="cov0" title="0">{
        lambdaService, err := l.getLambdaService(ctx, input.ProviderContext)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">functionARN := core.StringValue(
                input.CurrentResourceSpec.Fields["arn"],
        )

        functionOutput, err := lambdaService.GetFunction(
                ctx,
                &amp;lambda.GetFunctionInput{
                        FunctionName: &amp;functionARN,
                },
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resourceSpecState := &amp;core.MappingNode{
                Fields: map[string]*core.MappingNode{
                        "architecture": core.MappingNodeFromString(
                                string(functionOutput.Configuration.Architectures[0]),
                        ),
                        "code": functionCodeConfigToMappingNode(
                                functionOutput.Code,
                                input.CurrentResourceSpec.Fields["code"],
                        ),
                        "functionName": core.MappingNodeFromString(
                                aws.ToString(functionOutput.Configuration.FunctionName),
                        ),
                },
        }

        if functionOutput.Configuration.DeadLetterConfig != nil </span><span class="cov0" title="0">{
                resourceSpecState.Fields["deadLetterConfig"] = functionDeadLetterConfigToMappingNode(
                        functionOutput.Configuration.DeadLetterConfig,
                )
        }</span>

        <span class="cov0" title="0">if functionOutput.Configuration.Description != nil </span><span class="cov0" title="0">{
                resourceSpecState.Fields["description"] = core.MappingNodeFromString(
                        *functionOutput.Configuration.Description,
                )
        }</span>

        <span class="cov0" title="0">if functionOutput.Configuration.Environment != nil </span><span class="cov0" title="0">{
                resourceSpecState.Fields["environment"] = functionEnvToMappingNode(
                        functionOutput.Configuration.Environment,
                )
        }</span>

        <span class="cov0" title="0">if functionOutput.Configuration.EphemeralStorage != nil </span><span class="cov0" title="0">{
                resourceSpecState.Fields["ephemeralStorage"] = functionEphemeralStorageToMappingNode(
                        functionOutput.Configuration.EphemeralStorage,
                )
        }</span>

        <span class="cov0" title="0">if functionOutput.Configuration.FileSystemConfigs != nil </span><span class="cov0" title="0">{
                resourceSpecState.Fields["fileSystemConfig"] = functionFileSystemConfigsToMappingNode(
                        functionOutput.Configuration.FileSystemConfigs,
                )
        }</span>

        <span class="cov0" title="0">if functionOutput.Configuration.Handler != nil </span><span class="cov0" title="0">{
                resourceSpecState.Fields["handler"] = core.MappingNodeFromString(
                        aws.ToString(functionOutput.Configuration.Handler),
                )
        }</span>

        <span class="cov0" title="0">if functionOutput.Configuration.ImageConfigResponse != nil </span><span class="cov0" title="0">{
                resourceSpecState.Fields["imageConfig"] = functionImageConfigToMappingNode(
                        functionOutput.Configuration.ImageConfigResponse,
                )
        }</span>

        <span class="cov0" title="0">if functionOutput.Configuration.KMSKeyArn != nil </span><span class="cov0" title="0">{
                resourceSpecState.Fields["kmsKeyArn"] = core.MappingNodeFromString(
                        aws.ToString(functionOutput.Configuration.KMSKeyArn),
                )
        }</span>

        <span class="cov0" title="0">if functionOutput.Configuration.Layers != nil </span><span class="cov0" title="0">{
                resourceSpecState.Fields["layers"] = functionLayersToMappingNode(
                        functionOutput.Configuration.Layers,
                )
        }</span>

        <span class="cov0" title="0">if functionOutput.Configuration.LoggingConfig != nil </span><span class="cov0" title="0">{
                resourceSpecState.Fields["loggingConfig"] = functionLoggingConfigToMappingNode(
                        functionOutput.Configuration.LoggingConfig,
                )
        }</span>

        <span class="cov0" title="0">if functionOutput.Configuration.MemorySize != nil </span><span class="cov0" title="0">{
                resourceSpecState.Fields["memorySize"] = core.MappingNodeFromInt(
                        int(aws.ToInt32(functionOutput.Configuration.MemorySize)),
                )
        }</span>

        <span class="cov0" title="0">if functionOutput.Configuration.PackageType != "" </span><span class="cov0" title="0">{
                resourceSpecState.Fields["packageType"] = core.MappingNodeFromString(
                        string(functionOutput.Configuration.PackageType),
                )
        }</span>

        <span class="cov0" title="0">if functionOutput.Configuration.Role != nil </span><span class="cov0" title="0">{
                resourceSpecState.Fields["role"] = core.MappingNodeFromString(
                        aws.ToString(functionOutput.Configuration.Role),
                )
        }</span>

        <span class="cov0" title="0">if functionOutput.Configuration.Runtime != "" </span><span class="cov0" title="0">{
                resourceSpecState.Fields["runtime"] = core.MappingNodeFromString(
                        string(functionOutput.Configuration.Runtime),
                )
        }</span>

        <span class="cov0" title="0">if functionOutput.Configuration.RuntimeVersionConfig != nil </span><span class="cov0" title="0">{
                resourceSpecState.Fields["runtimeManagementConfig"] = functionRuntimeVersionConfigToMappingNode(
                        functionOutput.Configuration.RuntimeVersionConfig,
                        input.CurrentResourceSpec.Fields["runtimeManagementConfig"],
                )
        }</span>

        <span class="cov0" title="0">if functionOutput.Configuration.SnapStart != nil </span><span class="cov0" title="0">{
                resourceSpecState.Fields["snapStart"] = functionSnapStartConfigToMappingNode(
                        functionOutput.Configuration.SnapStart,
                )
        }</span>

        <span class="cov0" title="0">if len(functionOutput.Tags) &gt; 0 </span><span class="cov0" title="0">{
                resourceSpecState.Fields["tags"] = utils.TagsToMappingNode(
                        functionOutput.Tags,
                )
        }</span>

        <span class="cov0" title="0">if functionOutput.Configuration.Timeout != nil </span><span class="cov0" title="0">{
                resourceSpecState.Fields["timeout"] = core.MappingNodeFromInt(
                        int(aws.ToInt32(functionOutput.Configuration.Timeout)),
                )
        }</span>

        <span class="cov0" title="0">if functionOutput.Configuration.TracingConfig != nil </span><span class="cov0" title="0">{
                resourceSpecState.Fields["tracingConfig"] = functionTracingConfigToMappingNode(
                        functionOutput.Configuration.TracingConfig,
                )
        }</span>

        <span class="cov0" title="0">if functionOutput.Configuration.VpcConfig != nil </span><span class="cov0" title="0">{
                resourceSpecState.Fields["vpcConfig"] = functionVPCConfigToMappingNode(
                        functionOutput.Configuration.VpcConfig,
                )
        }</span>

        <span class="cov0" title="0">err = l.addCodeSigningConfigToSpec(
                ctx,
                functionARN,
                resourceSpecState.Fields,
                lambdaService,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">err = l.addRecursionConfigToSpec(
                ctx,
                functionARN,
                resourceSpecState.Fields,
                lambdaService,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">err = l.addConcurrencyConfigToSpec(
                ctx,
                functionARN,
                resourceSpecState.Fields,
                lambdaService,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">l.addComputedFieldsToSpec(
                functionOutput,
                resourceSpecState.Fields,
        )

        return &amp;provider.ResourceGetExternalStateOutput{
                ResourceSpecState: resourceSpecState,
        }, nil</span>
}

func (l *lambdaFunctionResourceActions) addComputedFieldsToSpec(
        functionOutput *lambda.GetFunctionOutput,
        specFields map[string]*core.MappingNode,
) <span class="cov0" title="0">{
        specFields["arn"] = core.MappingNodeFromString(
                aws.ToString(functionOutput.Configuration.FunctionArn),
        )

        if functionOutput.Configuration.SnapStart != nil </span><span class="cov0" title="0">{
                specFields["snapsnapStartResponseApplyOn"] = core.MappingNodeFromString(
                        string(functionOutput.Configuration.SnapStart.ApplyOn),
                )
                specFields["snapStartResponseOptimizationStatus"] = core.MappingNodeFromString(
                        string(functionOutput.Configuration.SnapStart.OptimizationStatus),
                )
        }</span>
}

func (l *lambdaFunctionResourceActions) addCodeSigningConfigToSpec(
        ctx context.Context,
        functionARN string,
        specFields map[string]*core.MappingNode,
        lambdaService Service,
) error <span class="cov0" title="0">{
        codeSigningConfigOutput, err := lambdaService.GetFunctionCodeSigningConfig(
                ctx,
                &amp;lambda.GetFunctionCodeSigningConfigInput{
                        FunctionName: &amp;functionARN,
                },
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if codeSigningConfigOutput.CodeSigningConfigArn != nil </span><span class="cov0" title="0">{
                specFields["codeSigningConfigArn"] = core.MappingNodeFromString(
                        *codeSigningConfigOutput.CodeSigningConfigArn,
                )
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (l *lambdaFunctionResourceActions) addRecursionConfigToSpec(
        ctx context.Context,
        functionARN string,
        specFields map[string]*core.MappingNode,
        lambdaService Service,
) error <span class="cov0" title="0">{
        recursionConfigOutput, err := lambdaService.GetFunctionRecursionConfig(
                ctx,
                &amp;lambda.GetFunctionRecursionConfigInput{
                        FunctionName: &amp;functionARN,
                },
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if recursionConfigOutput.RecursiveLoop != "" </span><span class="cov0" title="0">{
                specFields["recursiveLoop"] = core.MappingNodeFromString(
                        string(recursionConfigOutput.RecursiveLoop),
                )
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (l *lambdaFunctionResourceActions) addConcurrencyConfigToSpec(
        ctx context.Context,
        functionARN string,
        specFields map[string]*core.MappingNode,
        lambdaService Service,
) error <span class="cov0" title="0">{
        concurrencyConfigOutput, err := lambdaService.GetFunctionConcurrency(
                ctx,
                &amp;lambda.GetFunctionConcurrencyInput{
                        FunctionName: &amp;functionARN,
                },
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if concurrencyConfigOutput.ReservedConcurrentExecutions != nil </span><span class="cov0" title="0">{
                specFields["reservedConcurrentExecutions"] = core.MappingNodeFromInt(
                        int(aws.ToInt32(concurrencyConfigOutput.ReservedConcurrentExecutions)),
                )
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func functionCodeConfigToMappingNode(
        code *types.FunctionCodeLocation,
        inputSpecCode *core.MappingNode,
) *core.MappingNode <span class="cov0" title="0">{
        if code == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">fields := map[string]*core.MappingNode{}

        // For code source fields for a `Zip` package type, the source config is
        // not available in the FunctionCodeLocation
        // in the response when fetching the function, a pre-signed URL is returned instead.
        // When retrieving external state for resources, if fields in the spec are not avialable
        // in the upstream provider response, they will be set to the value in the input spec.
        if s3Bucket, hasBucket := inputSpecCode.Fields["s3Bucket"]; hasBucket </span><span class="cov0" title="0">{
                fields["s3Bucket"] = s3Bucket
        }</span>
        <span class="cov0" title="0">if s3Key, hasKey := inputSpecCode.Fields["s3Key"]; hasKey </span><span class="cov0" title="0">{
                fields["s3Key"] = s3Key
        }</span>
        <span class="cov0" title="0">if s3ObjectVersion, hasVersion := inputSpecCode.Fields["s3ObjectVersion"]; hasVersion </span><span class="cov0" title="0">{
                fields["s3ObjectVersion"] = s3ObjectVersion
        }</span>
        <span class="cov0" title="0">if zipFile, hasZipFile := inputSpecCode.Fields["zipFile"]; hasZipFile </span><span class="cov0" title="0">{
                fields["zipFile"] = zipFile
        }</span>

        <span class="cov0" title="0">if code.ImageUri != nil </span><span class="cov0" title="0">{
                fields["imageUri"] = core.MappingNodeFromString(aws.ToString(code.ImageUri))
        }</span>

        <span class="cov0" title="0">if code.SourceKMSKeyArn != nil </span><span class="cov0" title="0">{
                fields["sourceKMSKeyArn"] = core.MappingNodeFromString(aws.ToString(code.SourceKMSKeyArn))
        }</span>

        <span class="cov0" title="0">return &amp;core.MappingNode{Fields: fields}</span>
}

func functionDeadLetterConfigToMappingNode(
        deadLetterConfig *types.DeadLetterConfig,
) *core.MappingNode <span class="cov0" title="0">{
        return &amp;core.MappingNode{
                Fields: map[string]*core.MappingNode{
                        "targetArn": core.MappingNodeFromString(
                                aws.ToString(deadLetterConfig.TargetArn),
                        ),
                },
        }
}</span>

func functionEnvToMappingNode(
        environment *types.EnvironmentResponse,
) *core.MappingNode <span class="cov0" title="0">{
        if environment.Variables == nil </span><span class="cov0" title="0">{
                return &amp;core.MappingNode{
                        Fields: map[string]*core.MappingNode{},
                }
        }</span>

        <span class="cov0" title="0">variables := make(map[string]*core.MappingNode, len(environment.Variables))
        for key, value := range environment.Variables </span><span class="cov0" title="0">{
                variables[key] = core.MappingNodeFromString(value)
        }</span>

        <span class="cov0" title="0">return &amp;core.MappingNode{
                Fields: variables,
        }</span>
}

func functionEphemeralStorageToMappingNode(
        ephemeralStorage *types.EphemeralStorage,
) *core.MappingNode <span class="cov0" title="0">{
        if ephemeralStorage.Size == nil </span><span class="cov0" title="0">{
                return &amp;core.MappingNode{
                        Fields: map[string]*core.MappingNode{},
                }
        }</span>

        <span class="cov0" title="0">return &amp;core.MappingNode{
                Fields: map[string]*core.MappingNode{
                        "size": core.MappingNodeFromInt(int(
                                aws.ToInt32(ephemeralStorage.Size),
                        )),
                },
        }</span>
}

func functionFileSystemConfigsToMappingNode(
        fileSystemConfigs []types.FileSystemConfig,
) *core.MappingNode <span class="cov0" title="0">{
        if len(fileSystemConfigs) == 0 </span><span class="cov0" title="0">{
                return &amp;core.MappingNode{
                        Fields: map[string]*core.MappingNode{},
                }
        }</span>
        <span class="cov0" title="0">return &amp;core.MappingNode{
                Fields: map[string]*core.MappingNode{
                        "arn": core.MappingNodeFromString(
                                aws.ToString(fileSystemConfigs[0].Arn),
                        ),
                        "localMountPath": core.MappingNodeFromString(
                                aws.ToString(fileSystemConfigs[0].LocalMountPath),
                        ),
                },
        }</span>
}

func functionImageConfigToMappingNode(
        imageConfigResponse *types.ImageConfigResponse,
) *core.MappingNode <span class="cov0" title="0">{
        if imageConfigResponse.ImageConfig == nil </span><span class="cov0" title="0">{
                return &amp;core.MappingNode{
                        Fields: map[string]*core.MappingNode{},
                }
        }</span>

        <span class="cov0" title="0">fields := map[string]*core.MappingNode{}

        if imageConfigResponse.ImageConfig.Command != nil </span><span class="cov0" title="0">{
                fields["command"] = core.MappingNodeFromStringSlice(
                        imageConfigResponse.ImageConfig.Command,
                )
        }</span>

        <span class="cov0" title="0">if imageConfigResponse.ImageConfig.EntryPoint != nil </span><span class="cov0" title="0">{
                fields["entryPoint"] = core.MappingNodeFromStringSlice(
                        imageConfigResponse.ImageConfig.EntryPoint,
                )
        }</span>

        <span class="cov0" title="0">if imageConfigResponse.ImageConfig.WorkingDirectory != nil </span><span class="cov0" title="0">{
                fields["workingDirectory"] = core.MappingNodeFromString(
                        aws.ToString(imageConfigResponse.ImageConfig.WorkingDirectory),
                )
        }</span>

        <span class="cov0" title="0">return &amp;core.MappingNode{
                Fields: fields,
        }</span>
}

func functionLayersToMappingNode(
        layers []types.Layer,
) *core.MappingNode <span class="cov0" title="0">{
        if len(layers) == 0 </span><span class="cov0" title="0">{
                return &amp;core.MappingNode{
                        Items: []*core.MappingNode{},
                }
        }</span>

        <span class="cov0" title="0">items := make([]*core.MappingNode, len(layers))
        for i, layer := range layers </span><span class="cov0" title="0">{
                items[i] = core.MappingNodeFromString(aws.ToString(layer.Arn))
        }</span>

        <span class="cov0" title="0">return &amp;core.MappingNode{
                Items: items,
        }</span>
}

func functionLoggingConfigToMappingNode(
        loggingConfig *types.LoggingConfig,
) *core.MappingNode <span class="cov0" title="0">{
        if loggingConfig == nil </span><span class="cov0" title="0">{
                return &amp;core.MappingNode{
                        Fields: map[string]*core.MappingNode{},
                }
        }</span>

        <span class="cov0" title="0">fields := map[string]*core.MappingNode{}

        if loggingConfig.ApplicationLogLevel != "" </span><span class="cov0" title="0">{
                fields["applicationLogLevel"] = core.MappingNodeFromString(
                        string(loggingConfig.ApplicationLogLevel),
                )
        }</span>

        <span class="cov0" title="0">if loggingConfig.LogFormat != "" </span><span class="cov0" title="0">{
                fields["logFormat"] = core.MappingNodeFromString(
                        string(loggingConfig.LogFormat),
                )
        }</span>

        <span class="cov0" title="0">if loggingConfig.LogGroup != nil </span><span class="cov0" title="0">{
                fields["logGroup"] = core.MappingNodeFromString(
                        aws.ToString(loggingConfig.LogGroup),
                )
        }</span>

        <span class="cov0" title="0">if loggingConfig.SystemLogLevel != "" </span><span class="cov0" title="0">{
                fields["systemLogLevel"] = core.MappingNodeFromString(
                        string(loggingConfig.SystemLogLevel),
                )
        }</span>

        <span class="cov0" title="0">return &amp;core.MappingNode{
                Fields: fields,
        }</span>
}

func functionRuntimeVersionConfigToMappingNode(
        runtimeVersionConfig *types.RuntimeVersionConfig,
        inputSpecRuntimeVersionConfig *core.MappingNode,
) *core.MappingNode <span class="cov0" title="0">{
        fields := map[string]*core.MappingNode{}

        if runtimeVersionConfig.RuntimeVersionArn != nil </span><span class="cov0" title="0">{
                fields["runtimeVersionArn"] = core.MappingNodeFromString(
                        aws.ToString(runtimeVersionConfig.RuntimeVersionArn),
                )
        }</span>

        // The `updateRuntimeOn` field is an input when saving a lambda function but is not persisted
        // as part of the resource state in AWS, so like other fields that are input-only,
        // it is sourced from the input spec.
        <span class="cov0" title="0">if updateRuntimeOn, ok := inputSpecRuntimeVersionConfig.Fields["updateRuntimeOn"]; ok </span><span class="cov0" title="0">{
                fields["updateRuntimeOn"] = updateRuntimeOn
        }</span>

        <span class="cov0" title="0">return &amp;core.MappingNode{
                Fields: fields,
        }</span>
}

func functionSnapStartConfigToMappingNode(
        snapStartConfig *types.SnapStartResponse,
) *core.MappingNode <span class="cov0" title="0">{
        fields := map[string]*core.MappingNode{}

        if snapStartConfig.ApplyOn != "" </span><span class="cov0" title="0">{
                fields["applyOn"] = core.MappingNodeFromString(
                        string(snapStartConfig.ApplyOn),
                )
        }</span>

        <span class="cov0" title="0">return &amp;core.MappingNode{
                Fields: fields,
        }</span>
}

func functionTracingConfigToMappingNode(
        tracingConfig *types.TracingConfigResponse,
) *core.MappingNode <span class="cov0" title="0">{
        fields := map[string]*core.MappingNode{}

        if tracingConfig.Mode != "" </span><span class="cov0" title="0">{
                fields["mode"] = core.MappingNodeFromString(
                        string(tracingConfig.Mode),
                )
        }</span>

        <span class="cov0" title="0">return &amp;core.MappingNode{
                Fields: fields,
        }</span>
}

func functionVPCConfigToMappingNode(
        vpcConfig *types.VpcConfigResponse,
) *core.MappingNode <span class="cov0" title="0">{
        fields := map[string]*core.MappingNode{}

        if vpcConfig.SecurityGroupIds != nil </span><span class="cov0" title="0">{
                fields["securityGroupIds"] = core.MappingNodeFromStringSlice(
                        vpcConfig.SecurityGroupIds,
                )
        }</span>

        <span class="cov0" title="0">if vpcConfig.SubnetIds != nil </span><span class="cov0" title="0">{
                fields["subnetIds"] = core.MappingNodeFromStringSlice(
                        vpcConfig.SubnetIds,
                )
        }</span>

        <span class="cov0" title="0">if vpcConfig.Ipv6AllowedForDualStack != nil </span><span class="cov0" title="0">{
                fields["ipv6AllowedForDualStack"] = core.MappingNodeFromBool(
                        aws.ToBool(vpcConfig.Ipv6AllowedForDualStack),
                )
        }</span>

        <span class="cov0" title="0">return &amp;core.MappingNode{
                Fields: fields,
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package lambda

import (
        "github.com/two-hundred/celerity/libs/blueprint/core"
        "github.com/two-hundred/celerity/libs/blueprint/provider"
)

func lambdaFunctionResourceSchema() *provider.ResourceDefinitionsSchema <span class="cov0" title="0">{
        return &amp;provider.ResourceDefinitionsSchema{
                Type:        provider.ResourceDefinitionsSchemaTypeObject,
                Label:       "LambdaFunctionDefinition",
                Description: "The definition of an AWS Lambda function.",
                Required:    []string{"functionName", "code", "role"},
                Attributes: map[string]*provider.ResourceDefinitionsSchema{
                        "architecture": {
                                Type:        provider.ResourceDefinitionsSchemaTypeString,
                                Description: "The instruction set architecture that the function supports.",
                                Default:     core.MappingNodeFromString("x86_64"),
                                AllowedValues: []*core.MappingNode{
                                        core.MappingNodeFromString("x86_64"),
                                        core.MappingNodeFromString("arm64"),
                                },
                                Nullable: true,
                        },
                        "code": {
                                Type:  provider.ResourceDefinitionsSchemaTypeObject,
                                Label: "FunctionCode",
                                Description: "The code for the Lambda function. You can either specify an object in Amazon S3," +
                                        " upload a .zip file archive deployment package directly, or specify the URI of a container image.",
                                Attributes: map[string]*provider.ResourceDefinitionsSchema{
                                        "imageUri": {
                                                Type:                 provider.ResourceDefinitionsSchemaTypeString,
                                                Description:          "The URI of the container image in the Amazon ECR registry.",
                                                FormattedDescription: "The URI of a [container image](https://docs.aws.amazon.com/lambda/latest/dg/images-create.html) in the Amazon ECR registry.",
                                        },
                                        "s3Bucket": {
                                                Type: provider.ResourceDefinitionsSchemaTypeString,
                                                Description: "An Amazon S3 bucket in the same AWS Region as the function. " +
                                                        "The bucket can be in a different AWS account.",
                                                // We can't do a negative lookbehind with Go's regexp engine, the regexp
                                                // for the bucket name in the official AWS API documentation for Lambda
                                                // includes a negative lookbehind to ensure that a bucket name that consists
                                                // of only a single period (".") is not allowed.
                                                // Due to this, bucket names that start with "." will fail validation
                                                // with the provider.
                                                Pattern:   "^[0-9A-Za-z\\-_][0-9A-Za-z\\.\\-_]+$",
                                                MinLength: 3,
                                                MaxLength: 63,
                                        },
                                        "s3Key": {
                                                Type:        provider.ResourceDefinitionsSchemaTypeString,
                                                Description: "The Amazon S3 key of the deployment package.",
                                                MinLength:   1,
                                                MaxLength:   1024,
                                        },
                                        "s3ObjectVersion": {
                                                Type:        provider.ResourceDefinitionsSchemaTypeString,
                                                Description: "For versioned objects, the version of the deployment package object to use.",
                                                MinLength:   1,
                                                MaxLength:   1024,
                                        },
                                        "sourceKMSKeyArn": {
                                                Type: provider.ResourceDefinitionsSchemaTypeString,
                                                Description: "The ARN of the AWS Key Management Service (AWS KMS) customer managed key that's used to " +
                                                        "encrypt your function's .zip deployment package. If you do not provide a custom managed key, " +
                                                        "Lambda uses an AWS owned key.",
                                                FormattedDescription: "The ARN of the AWS Key Management Service (AWS KMS) customer managed key that's used to " +
                                                        "encrypt your function's .zip deployment package. If you do not provide a custom managed key, " +
                                                        "Lambda uses an [AWS owned key](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#aws-owned-cmk).",
                                                Pattern: "(arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()",
                                        },
                                        "zipFile": {
                                                Type:        provider.ResourceDefinitionsSchemaTypeString,
                                                Description: "The inline code for the Lambda function. This will be converted into a base-64 encoded zip archive format by the provider.",
                                        },
                                },
                        },
                        "codeSigningConfigArn": {
                                Type: provider.ResourceDefinitionsSchemaTypeString,
                                Description: "To enable code signing for this function, specify the ARN of code-signing configuration. " +
                                        "A code-signing configuration includes a set of signing profiles, which define the trusted publishers " +
                                        "for this function.",
                                Pattern: "arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\\d{1}:\\d{12}:code-signing-config:csc-[a-z0-9]{17}",
                        },
                        "deadLetterConfig": {
                                Type:        provider.ResourceDefinitionsSchemaTypeObject,
                                Label:       "DeadLetterConfig",
                                Description: "The dead-letter queue for failed asynchronous invocations.",
                                FormattedDescription: "The [dead-letter queue](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async-retain-records.html#invocation-dlq) " +
                                        "for failed asynchronous invocations.",
                                Attributes: map[string]*provider.ResourceDefinitionsSchema{
                                        "targetArn": {
                                                Type:        provider.ResourceDefinitionsSchemaTypeString,
                                                Description: "The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.",
                                                Pattern:     "(arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()",
                                        },
                                },
                        },
                        "description": {
                                Type:        provider.ResourceDefinitionsSchemaTypeString,
                                Description: "A description of the function.",
                                MaxLength:   256,
                        },
                        "environment": {
                                Type:  provider.ResourceDefinitionsSchemaTypeObject,
                                Label: "Environment",
                                Description: "A function's environment variable settings. You can use environment variables to adjust your " +
                                        "function's behavior without updating code. An environment variable is a pair of strings that are stored in a function's version-specific configuration.",
                                Attributes: map[string]*provider.ResourceDefinitionsSchema{
                                        "variables": {
                                                Type: provider.ResourceDefinitionsSchemaTypeMap,
                                                MapValues: &amp;provider.ResourceDefinitionsSchema{
                                                        Type: provider.ResourceDefinitionsSchemaTypeString,
                                                },
                                                Description: "Environment variable key-value pairs. Keys must follow the pattern \"[a-zA-Z]([a-zA-Z0-9_])+\".",
                                                FormattedDescription: "Environment variable key-value pairs. For more information, see " +
                                                        "[Using Lambda environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html). " +
                                                        "Keys must follow the pattern `[a-zA-Z]([a-zA-Z0-9_])+`.",
                                        },
                                },
                        },
                        "ephemeralStorage": {
                                Type:  provider.ResourceDefinitionsSchemaTypeObject,
                                Label: "EphemeralStorage",
                                Description: "The size of the function's \"tmp\" directory in MB. The default value is 512," +
                                        " but can be any whole number between 512 and 10,240 MB.",
                                FormattedDescription: "The size of the function's `tmp` directory in MB. The default value is 512," +
                                        " but can be any whole number between 512 and 10,240 MB. For more information, see " +
                                        "[Configuring ephemeral storage (console)](https://docs.aws.amazon.com/lambda/latest/dg/lambda-functions.html#configuration-ephemeral-storage)",
                                Required: []string{"size"},
                                Attributes: map[string]*provider.ResourceDefinitionsSchema{
                                        "size": {
                                                Type: provider.ResourceDefinitionsSchemaTypeInteger,
                                                Description: "The size of the function's `tmp` directory in MB. " +
                                                        "Can have a minimum value of 512 and a maximum value of 10240.",
                                                Minimum: core.ScalarFromInt(512),
                                                Maximum: core.ScalarFromInt(10240),
                                        },
                                },
                        },
                        "fileSystemConfig": {
                                Type:        provider.ResourceDefinitionsSchemaTypeObject,
                                Label:       "FileSystemConfig",
                                Description: "Details about the connection between a Lambda function and an Amazon EFS file system.",
                                FormattedDescription: "Details about the connection between a Lambda function and " +
                                        "an [Amazon EFS file system](https://docs.aws.amazon.com/lambda/latest/dg/configuration-filesystem.html).",
                                Required: []string{"arn", "localMountPath"},
                                Attributes: map[string]*provider.ResourceDefinitionsSchema{
                                        "arn": {
                                                Type: provider.ResourceDefinitionsSchemaTypeString,
                                                Description: "The Amazon Resource Name (ARN) of the Amazon EFS access" +
                                                        " point that provides access to the file system.",
                                                Pattern:   "arn:aws[a-zA-Z-]*:elasticfilesystem:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\\d{1}:\\d{12}:access-point/fsap-[a-f0-9]{17}",
                                                MaxLength: 200,
                                        },
                                        "localMountPath": {
                                                Type:        provider.ResourceDefinitionsSchemaTypeString,
                                                Description: "The path where the function can access the file system, starting with /mnt/.",
                                                Pattern:     "^/mnt/[a-zA-Z0-9-_.]+$",
                                                MaxLength:   160,
                                        },
                                },
                        },
                        "functionName": {
                                Type:        provider.ResourceDefinitionsSchemaTypeString,
                                Description: "The name of the Lambda function stored in the AWS system.",
                                Examples: []*core.MappingNode{
                                        core.MappingNodeFromString("MyFunction"),
                                },
                                MinLength:    1,
                                MaxLength:    64,
                                MustRecreate: true,
                        },
                        "handler": {
                                Type: provider.ResourceDefinitionsSchemaTypeString,
                                Description: "The name of the method within your code that Lambda calls to execute your function." +
                                        " This is required if the deployment package is a .zip file archive. The format includes the file name." +
                                        " It can also include namespaces and other qualifiers, depending on the runtime.",
                                FormattedDescription: "The name of the method within your code that Lambda calls to execute your function." +
                                        " This is required if the deployment package is a .zip file archive. The format includes the file name." +
                                        " It can also include namespaces and other qualifiers, depending on the runtime." +
                                        " For more information, see [Lambda programming model](https://docs.aws.amazon.com/lambda/latest/dg/foundation-progmodel.html)",
                                Examples: []*core.MappingNode{
                                        core.MappingNodeFromString("index.handler"),
                                        core.MappingNodeFromString("lambda_function.lambda_handler"),
                                },
                                MaxLength: 128,
                                Pattern:   "^[^\\s]+$",
                        },
                        "imageConfig": {
                                Type:        provider.ResourceDefinitionsSchemaTypeObject,
                                Label:       "ImageConfig",
                                Description: "Configuration values that override the container image Dockerfile settings.",
                                FormattedDescription: "Configuration values that override the container image Dockerfile settings. " +
                                        "For more information, see [Container image settings](https://docs.aws.amazon.com/lambda/latest/dg/images-create.html#images-parms)",
                                Attributes: map[string]*provider.ResourceDefinitionsSchema{
                                        "command": {
                                                Type:        provider.ResourceDefinitionsSchemaTypeArray,
                                                Description: "Specifies the parameters that you want to pass in with ENTRYPOINT. You can specify a maximum of 1,500 parameters in the list.",
                                                Items: &amp;provider.ResourceDefinitionsSchema{
                                                        Type: provider.ResourceDefinitionsSchemaTypeString,
                                                },
                                                MaxLength: 1500,
                                        },
                                        "entryPoint": {
                                                Type: provider.ResourceDefinitionsSchemaTypeArray,
                                                Description: "Specifies the entry point to the application, which is typically the location of the runtime executable. " +
                                                        "You can specify a maximum of 1,500 entries in the list.",
                                                Items: &amp;provider.ResourceDefinitionsSchema{
                                                        Type: provider.ResourceDefinitionsSchemaTypeString,
                                                },
                                                MaxLength: 1500,
                                        },
                                        "workingDirectory": {
                                                Type:        provider.ResourceDefinitionsSchemaTypeString,
                                                Description: "Specifies the working directory. The length of the directory string cannot exceed 1,000 characters.",
                                                MaxLength:   1000,
                                        },
                                },
                        },
                        "kmsKeyArn": {
                                Type: provider.ResourceDefinitionsSchemaTypeString,
                                Description: "The ARN of the AWS Key Management Service (AWS KMS) customer managed key that's used to " +
                                        "encrypt your function's environment variables.",
                                FormattedDescription: "The ARN of the AWS Key Management Service (AWS KMS) customer managed key that's used to " +
                                        "encrypt your function's environment variables. When this configuration is not provided, AWS Lambda uses " +
                                        "a default service key.",
                                Pattern: "^(arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()$",
                        },
                        "layers": {
                                Type:        provider.ResourceDefinitionsSchemaTypeArray,
                                Description: "A list of function layers to add to the function's execution environment.",
                                FormattedDescription: "A list of [function layers](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html) " +
                                        "to add to the function's execution environment. Specify each layer by its ARN, including the version.",
                                Items: &amp;provider.ResourceDefinitionsSchema{
                                        Type:        provider.ResourceDefinitionsSchemaTypeString,
                                        Description: "The ARN of a layer version.",
                                },
                        },
                        "loggingConfig": {
                                Type:                 provider.ResourceDefinitionsSchemaTypeObject,
                                Label:                "LoggingConfig",
                                Description:          "The function's Amazon CloudWatch logging configuration.",
                                FormattedDescription: "The function's [Amazon CloudWatch logging configuration](https://docs.aws.amazon.com/lambda/latest/dg/monitoring-cloudwatchlogs.html).",
                                Attributes: map[string]*provider.ResourceDefinitionsSchema{
                                        "applicationLogLevel": {
                                                Type: provider.ResourceDefinitionsSchemaTypeString,
                                                Description: "A property to filter the application logs for your function that Lambda sends to CloudWatch. " +
                                                        "Lambda only sends application logs at the selected level of detail and lower, where TRACE is the highest level and FATAL is the lowest.",
                                                FormattedDescription: "A property to filter the application logs for your function that Lambda sends to CloudWatch. " +
                                                        "Lambda only sends application logs at the selected level of detail and lower, where `TRACE` is the highest level and `FATAL` is the lowest.",
                                                AllowedValues: []*core.MappingNode{
                                                        core.MappingNodeFromString("TRACE"),
                                                        core.MappingNodeFromString("DEBUG"),
                                                        core.MappingNodeFromString("INFO"),
                                                        core.MappingNodeFromString("WARN"),
                                                        core.MappingNodeFromString("ERROR"),
                                                        core.MappingNodeFromString("FATAL"),
                                                },
                                        },
                                        "logFormat": {
                                                Type:        provider.ResourceDefinitionsSchemaTypeString,
                                                Description: "The format of the log records that the function sends to CloudWatch Logs.",
                                                AllowedValues: []*core.MappingNode{
                                                        core.MappingNodeFromString("JSON"),
                                                        core.MappingNodeFromString("Text"),
                                                },
                                        },
                                        "logGroup": {
                                                Type:        provider.ResourceDefinitionsSchemaTypeString,
                                                Description: "The name of the CloudWatch Logs group the function sends logs to.",
                                                Pattern:     "[\\.\\-_/#A-Za-z0-9]+",
                                        },
                                        "systemLogLevel": {
                                                Type: provider.ResourceDefinitionsSchemaTypeString,
                                                Description: "A property to filter the system logs for your function that Lambda sends to CloudWatch." +
                                                        "Lambda only sends system logs at the selected level of detail and lower, where DEBUG is the highest level and WARN is the lowest.",
                                                FormattedDescription: "A property to filter the system logs for your function that Lambda sends to CloudWatch." +
                                                        "Lambda only sends system logs at the selected level of detail and lower, where `DEBUG` is the highest level and `WARN` is the lowest.",
                                                AllowedValues: []*core.MappingNode{
                                                        core.MappingNodeFromString("DEBUG"),
                                                        core.MappingNodeFromString("INFO"),
                                                        core.MappingNodeFromString("WARN"),
                                                },
                                        },
                                },
                        },
                        "memorySize": {
                                Type: provider.ResourceDefinitionsSchemaTypeInteger,
                                Description: "The amount of memory available to the function at runtime. " +
                                        "Increasing the function memory also increases its CPU allocation. " +
                                        "The default value is 128 MB. The value can be any multiple of 1 MB. " +
                                        "Note that new AWS accounts have reduced concurrency and memory quotas. " +
                                        "AWS raises these quotas automatically based on your usage. " +
                                        "You can also request a quota increase.",
                                FormattedDescription: "The amount of [memory available to the function](https://docs.aws.amazon.com/lambda/latest/dg/configuration-function-common.html#configuration-memory-console) at runtime. " +
                                        "Increasing the function memory also increases its CPU allocation. " +
                                        "The default value is 128 MB. The value can be any multiple of 1 MB. " +
                                        "Note that new AWS accounts have reduced concurrency and memory quotas. " +
                                        "AWS raises these quotas automatically based on your usage. " +
                                        "You can also request a quota increase.",
                                Default: core.MappingNodeFromInt(128),
                                Examples: []*core.MappingNode{
                                        core.MappingNodeFromInt(128),
                                        core.MappingNodeFromInt(512),
                                        core.MappingNodeFromInt(1024),
                                },
                        },
                        "packageType": {
                                Type:        provider.ResourceDefinitionsSchemaTypeString,
                                Description: "The type of deployment package.",
                                Default:     core.MappingNodeFromString("Zip"),
                                AllowedValues: []*core.MappingNode{
                                        core.MappingNodeFromString("Zip"),
                                        core.MappingNodeFromString("Image"),
                                },
                                MustRecreate: true,
                        },
                        "recursiveLoop": {
                                Type: provider.ResourceDefinitionsSchemaTypeString,
                                Description: "The status of your function's recursive loop detection configuration.\n\n" +
                                        "When this value is set to Allow and Lambda detcts your function being invoked as part of a recursive loop, it doesn't take any action.\n\n" +
                                        "When this value is set to Terminate and Lambda detects your function being invoked as part of a recursive loop, it stops your function being invoked and notifies you.",
                                FormattedDescription: "The status of your function's recursive loop detection configuration.\n\n" +
                                        "When this value is set to `Allow` and Lambda detcts your function being invoked as part of a recursive loop, it doesn't take any action.\n\n" +
                                        "When this value is set to `Terminate` and Lambda detects your function being invoked as part of a recursive loop, it stops your function being invoked and notifies you.",
                                AllowedValues: []*core.MappingNode{
                                        core.MappingNodeFromString("Allow"),
                                        core.MappingNodeFromString("Terminate"),
                                },
                        },
                        "reservedConcurrentExecutions": {
                                Type:        provider.ResourceDefinitionsSchemaTypeInteger,
                                Description: "The number of simultaneous executions to reserve for the function.",
                                Minimum:     core.ScalarFromInt(0),
                        },
                        "role": {
                                Type: provider.ResourceDefinitionsSchemaTypeString,
                                Description: "The Amazon Resource Name (ARN) of the function's execution role that grants the function " +
                                        "permission to access AWS services and resources.",
                                Pattern: "^arn:(aws[a-zA-Z-]*)?:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$",
                        },
                        "runtime": {
                                Type: provider.ResourceDefinitionsSchemaTypeString,
                                Description: "The identifier of the function's runtime. " +
                                        "Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in an error " +
                                        "if you're deploying a function using a container image.",
                                FormattedDescription: "The identifier of the function's [runtime](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html). " +
                                        "Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in an error " +
                                        "if you're deploying a function using a container image.\n\n" +
                                        "The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing functions " +
                                        "shortly after each runtime is deprecated. For more information, see [Runtime use after deprecation](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-deprecation-levels).\n\n" +
                                        "For a list of all currently supported runtimes, see [Supported runtimes](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtimes-supported)",
                                AllowedValues: []*core.MappingNode{
                                        core.MappingNodeFromString("nodejs"),
                                        core.MappingNodeFromString("nodejs4.3"),
                                        core.MappingNodeFromString("nodejs4.3-edge"),
                                        core.MappingNodeFromString("nodejs6.10"),
                                        core.MappingNodeFromString("nodejs8.10"),
                                        core.MappingNodeFromString("nodejs10.x"),
                                        core.MappingNodeFromString("nodejs12.x"),
                                        core.MappingNodeFromString("nodejs14.x"),
                                        core.MappingNodeFromString("nodejs16.x"),
                                        core.MappingNodeFromString("nodejs18.x"),
                                        core.MappingNodeFromString("nodejs20.x"),
                                        core.MappingNodeFromString("nodejs22.x"),
                                        core.MappingNodeFromString("java8"),
                                        core.MappingNodeFromString("java8.al2"),
                                        core.MappingNodeFromString("java11"),
                                        core.MappingNodeFromString("java17"),
                                        core.MappingNodeFromString("java21"),
                                        core.MappingNodeFromString("python2.7"),
                                        core.MappingNodeFromString("python3.6"),
                                        core.MappingNodeFromString("python3.7"),
                                        core.MappingNodeFromString("python3.8"),
                                        core.MappingNodeFromString("python3.9"),
                                        core.MappingNodeFromString("python3.10"),
                                        core.MappingNodeFromString("python3.11"),
                                        core.MappingNodeFromString("python3.12"),
                                        core.MappingNodeFromString("python3.13"),
                                        core.MappingNodeFromString("dotnetcore1.0"),
                                        core.MappingNodeFromString("dotnetcore2.0"),
                                        core.MappingNodeFromString("dotnetcore2.1"),
                                        core.MappingNodeFromString("dotnetcore3.1"),
                                        core.MappingNodeFromString("dotnet6"),
                                        core.MappingNodeFromString("dotnet7"),
                                        core.MappingNodeFromString("dotnet8"),
                                        core.MappingNodeFromString("go1.x"),
                                        core.MappingNodeFromString("ruby2.5"),
                                        core.MappingNodeFromString("ruby2.7"),
                                        core.MappingNodeFromString("ruby3.2"),
                                        core.MappingNodeFromString("ruby3.3"),
                                        core.MappingNodeFromString("ruby3.4"),
                                        core.MappingNodeFromString("provided"),
                                        core.MappingNodeFromString("provided.al2"),
                                        core.MappingNodeFromString("provided.al2023"),
                                },
                        },
                        "runtimeManagementConfig": {
                                Type:        provider.ResourceDefinitionsSchemaTypeObject,
                                Label:       "RuntimeManagementConfig",
                                Required:    []string{"updateRuntimeOn"},
                                Description: "Sets the runtime management configuration for a function's version.",
                                FormattedDescription: "Sets the runtime management configuration for a function's version. " +
                                        "For more information, see [Runtime updates](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-update.html).",
                                Attributes: map[string]*provider.ResourceDefinitionsSchema{
                                        "runtimeVersionArn": {
                                                Type:        provider.ResourceDefinitionsSchemaTypeString,
                                                Description: "The ARN of the runtime version you want the function to use.",
                                                FormattedDescription: "The ARN of the runtime version you want the function to use.\n\n" +
                                                        "&gt; This is only required if you're using the **Manual** runtime update mode.",
                                                Pattern:   "^arn:(aws[a-zA-Z-]*):lambda:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\\d{1}::runtime:.+$",
                                                MinLength: 26,
                                                MaxLength: 2048,
                                        },
                                        "updateRuntimeOn": {
                                                Type:        provider.ResourceDefinitionsSchemaTypeString,
                                                Description: "The runtime update mode to use.",
                                                FormattedDescription: "The runtime update mode to use.\n\n" +
                                                        "- **Auto (default)** - Automatically update to the most recent and secure runtime " +
                                                        "version using a [Two-phase runtime version rollout](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-update.html#runtime-management-two-phase)." +
                                                        " This is the best choice for most cases as it ensures you will always benefit from runtime updates.\n" +
                                                        "- **FunctionUpdate** - Lambda updates the runtime of your function to the most recent and secure runtime version " +
                                                        "when you update your function. This approach synchronizes runtime updates with function deployments, " +
                                                        "giving you control over when runtime updates are applied and allowing you to detect and mitigate rare runtime update incompatibilities early. " +
                                                        "When using this setting, you need to regularly update your functions to keep their runtime up-to-date.\n" +
                                                        "- **Manual** - You specify a runtime version in your function configuration. " +
                                                        "The function will use this runtime version indefinitely. In the rare case where a runtime version is incompatible with an existing function, " +
                                                        "this allows you to roll back your function to an earlier runtime version. " +
                                                        "For more information, see [Roll back a runtime version](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-update.html#runtime-management-rollback).",
                                                AllowedValues: []*core.MappingNode{
                                                        core.MappingNodeFromString("Auto"),
                                                        core.MappingNodeFromString("FunctionUpdate"),
                                                        core.MappingNodeFromString("Manual"),
                                                },
                                        },
                                },
                        },
                        "snapStart": {
                                Type:                 provider.ResourceDefinitionsSchemaTypeObject,
                                Label:                "SnapStart",
                                Description:          "The function's AWS Lambda SnapStart setting.",
                                FormattedDescription: "The function's [AWS Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html) setting.",
                                Required:             []string{"applyOn"},
                                Attributes: map[string]*provider.ResourceDefinitionsSchema{
                                        "applyOn": {
                                                Type:        provider.ResourceDefinitionsSchemaTypeString,
                                                Description: "Set ApplyOn to PublishedVersions to create a snapshot of the initialized execution environment when you publish a function version.",
                                                AllowedValues: []*core.MappingNode{
                                                        core.MappingNodeFromString("PublishedVersions"),
                                                        core.MappingNodeFromString("None"),
                                                },
                                        },
                                },
                        },
                        "tags": {
                                Type:        provider.ResourceDefinitionsSchemaTypeArray,
                                Description: "A list of tags to apply to the function.",
                                FormattedDescription: "A list of [tags](https://docs.aws.amazon.com/lambda/latest/dg/tagging.html) " +
                                        "to apply to the function.",
                                Items: &amp;provider.ResourceDefinitionsSchema{
                                        Type:                 provider.ResourceDefinitionsSchemaTypeObject,
                                        Label:                "Tag",
                                        Description:          "A tag to apply to the function.",
                                        FormattedDescription: "A [tag](https://docs.aws.amazon.com/lambda/latest/dg/tagging.html) to apply to the function.",
                                        Required:             []string{"key", "value"},
                                        Attributes: map[string]*provider.ResourceDefinitionsSchema{
                                                "key": {
                                                        Type:        provider.ResourceDefinitionsSchemaTypeString,
                                                        Description: "The key of the tag.",
                                                        MinLength:   1,
                                                        MaxLength:   128,
                                                },
                                                "value": {
                                                        Type:        provider.ResourceDefinitionsSchemaTypeString,
                                                        Description: "The value of the tag.",
                                                        MinLength:   0,
                                                        MaxLength:   256,
                                                },
                                        },
                                },
                        },
                        "timeout": {
                                Type: provider.ResourceDefinitionsSchemaTypeInteger,
                                Description: "The amount of time (in seconds) that Lambda allows a function to run before stopping it. " +
                                        "The default is 3 seconds. The maximum allowed value is 900 seconds.",
                                FormattedDescription: "The amount of time (in seconds) that Lambda allows a function to run before stopping it. " +
                                        "The default is 3 seconds. The maximum allowed value is 900 seconds. " +
                                        "For more information, see [Lambda execution environment](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-context.html).",
                                Default: core.MappingNodeFromInt(3),
                                Minimum: core.ScalarFromInt(1),
                                Examples: []*core.MappingNode{
                                        core.MappingNodeFromInt(3),
                                        core.MappingNodeFromInt(30),
                                        core.MappingNodeFromInt(900),
                                },
                        },
                        "tracingConfig": {
                                Type:                 provider.ResourceDefinitionsSchemaTypeObject,
                                Label:                "TracingConfig",
                                Description:          "The function's AWS X-Ray tracing configuration.",
                                FormattedDescription: "The function's [AWS X-Ray tracing](https://docs.aws.amazon.com/lambda/latest/dg/services-xray.html) configuration.",
                                Attributes: map[string]*provider.ResourceDefinitionsSchema{
                                        "mode": {
                                                Type:        provider.ResourceDefinitionsSchemaTypeString,
                                                Description: "The tracing mode.",
                                                AllowedValues: []*core.MappingNode{
                                                        core.MappingNodeFromString("Active"),
                                                        core.MappingNodeFromString("PassThrough"),
                                                },
                                        },
                                },
                        },
                        "vpcConfig": {
                                Type:                 provider.ResourceDefinitionsSchemaTypeObject,
                                Label:                "VpcConfig",
                                Description:          "The VPC configuration for the function.",
                                FormattedDescription: "The [VPC configuration](https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html) for the function.",
                                Attributes: map[string]*provider.ResourceDefinitionsSchema{
                                        "securityGroupIds": {
                                                Type:        provider.ResourceDefinitionsSchemaTypeArray,
                                                Description: "A list of VPC security group IDs.",
                                                Items: &amp;provider.ResourceDefinitionsSchema{
                                                        Type: provider.ResourceDefinitionsSchemaTypeString,
                                                },
                                                MaxLength: 5,
                                        },
                                        "subnetIds": {
                                                Type:        provider.ResourceDefinitionsSchemaTypeArray,
                                                Description: "A list of VPC subnet IDs.",
                                                Items: &amp;provider.ResourceDefinitionsSchema{
                                                        Type: provider.ResourceDefinitionsSchemaTypeString,
                                                },
                                                MaxLength: 16,
                                        },
                                        "ipv6AllowedForDualStack": {
                                                Type:        provider.ResourceDefinitionsSchemaTypeBoolean,
                                                Description: "Allows outbound IPv6 traffic on VPC functions that are connected to dual-stack subnets.",
                                        },
                                },
                        },

                        // Computed fields
                        "arn": {
                                Type:        provider.ResourceDefinitionsSchemaTypeString,
                                Description: "The Amazon Resource Name (ARN) of the Lambda function.",
                                Computed:    true,
                        },
                        "snapStartResponseApplyOn": {
                                Type:        provider.ResourceDefinitionsSchemaTypeString,
                                Description: "When SnapStart is set to PublishedVersions, this field indicates the apply setting.",
                                Computed:    true,
                        },
                        "snapStartResponseOptimizationStatus": {
                                Type:        provider.ResourceDefinitionsSchemaTypeString,
                                Description: "The status of the SnapStart optimization.",
                                Computed:    true,
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package lambda

import (
        "context"
        "net/url"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/lambda"
        smithyendpoints "github.com/aws/smithy-go/endpoints"
        "github.com/two-hundred/celerity-provider-aws/utils"
        "github.com/two-hundred/celerity/libs/blueprint/core"
        "github.com/two-hundred/celerity/libs/blueprint/provider"
)

// Service is an interface that represents the functionality of the AWS Lambda service
// used by the Lambda resource implementation.
type Service interface {
        // Returns information about the function or function version, with a link to
        // download the deployment package that's valid for 10 minutes. If you specify a
        // function version, only details that are specific to that version are returned.
        GetFunction(ctx context.Context, params *lambda.GetFunctionInput, optFns ...func(*lambda.Options)) (*lambda.GetFunctionOutput, error)
        // Deletes a Lambda function. To delete a specific function version, use the
        // Qualifier parameter. Otherwise, all versions and aliases are deleted. This
        // doesn't require the user to have explicit permissions for DeleteAlias.
        //
        // To delete Lambda event source mappings that invoke a function, use DeleteEventSourceMapping. For Amazon
        // Web Services services and resources that invoke your function directly, delete
        // the trigger in the service where you originally configured it.
        DeleteFunction(ctx context.Context, params *lambda.DeleteFunctionInput, optFns ...func(*lambda.Options)) (*lambda.DeleteFunctionOutput, error)
        // Returns the code signing configuration for the specified function.
        GetFunctionCodeSigningConfig(
                ctx context.Context,
                params *lambda.GetFunctionCodeSigningConfigInput,
                optFns ...func(*lambda.Options),
        ) (*lambda.GetFunctionCodeSigningConfigOutput, error)
        // Returns your function's [recursive loop detection] configuration.
        //
        // [recursive loop detection]: https://docs.aws.amazon.com/lambda/latest/dg/invocation-recursion.html
        GetFunctionRecursionConfig(
                ctx context.Context,
                params *lambda.GetFunctionRecursionConfigInput,
                optFns ...func(*lambda.Options),
        ) (*lambda.GetFunctionRecursionConfigOutput, error)
        // Returns details about the reserved concurrency configuration for a function. To
        // set a concurrency limit for a function, use PutFunctionConcurrency.
        GetFunctionConcurrency(
                ctx context.Context,
                params *lambda.GetFunctionConcurrencyInput,
                optFns ...func(*lambda.Options),
        ) (*lambda.GetFunctionConcurrencyOutput, error)
}

// NewService creates a new instance of the AWS Lambda service
// based on the provided AWS configuration.
func NewService(awsConfig *aws.Config, providerContext provider.Context) Service <span class="cov0" title="0">{
        return lambda.NewFromConfig(
                *awsConfig,
                lambda.WithEndpointResolverV2(
                        &amp;lambdaEndpointResolverV2{
                                providerContext,
                        },
                ),
        )
}</span>

type lambdaEndpointResolverV2 struct {
        providerContext provider.Context
}

func (l *lambdaEndpointResolverV2) ResolveEndpoint(
        ctx context.Context,
        params lambda.EndpointParameters,
) (smithyendpoints.Endpoint, error) <span class="cov0" title="0">{
        lambdaAliases := utils.Services["lambda"]
        lambdaEndpoint, hasLambdaEndpoint := utils.GetEndpointFromProviderConfig(
                l.providerContext,
                "lambda",
                lambdaAliases,
        )
        if hasLambdaEndpoint &amp;&amp; !core.IsScalarNil(lambdaEndpoint) </span><span class="cov0" title="0">{
                u, err := url.Parse(core.StringValueFromScalar(lambdaEndpoint))
                if err != nil </span><span class="cov0" title="0">{
                        return smithyendpoints.Endpoint{}, err
                }</span>
                <span class="cov0" title="0">return smithyendpoints.Endpoint{
                        URI: *u,
                }, nil</span>
        }

        <span class="cov0" title="0">return lambda.NewDefaultEndpointResolverV2().ResolveEndpoint(ctx, params)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package utils

import (
        "bytes"
        "context"
        "crypto/tls"
        "log"
        "net/http"
        "net/url"
        "os"
        "strings"
        "time"

        "github.com/aws/aws-sdk-go-v2/aws"
        awshttp "github.com/aws/aws-sdk-go-v2/aws/transport/http"
        "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/credentials"
        "github.com/aws/aws-sdk-go-v2/credentials/stscreds"
        "github.com/aws/aws-sdk-go-v2/feature/ec2/imds"
        "github.com/aws/aws-sdk-go-v2/service/sts/types"
        "github.com/two-hundred/celerity/libs/blueprint/core"
        "github.com/two-hundred/celerity/libs/blueprint/provider"
)

// AWSConfigLoader defines the interface for loading AWS configurations
type AWSConfigLoader interface {
        LoadDefaultConfig(
                ctx context.Context,
                optFns ...func(*config.LoadOptions) error,
        ) (aws.Config, error)
}

// DefaultAWSConfigLoader implements AWSConfigLoader using the AWS SDK
type DefaultAWSConfigLoader struct{}

func (l *DefaultAWSConfigLoader) LoadDefaultConfig(
        ctx context.Context,
        optFns ...func(*config.LoadOptions) error,
) (aws.Config, error) <span class="cov0" title="0">{
        return config.LoadDefaultConfig(ctx, optFns...)
}</span>

// AWSConfigFromProviderContext creates an AWS config from the given
// provider context and environment variables.
func AWSConfigFromProviderContext(
        ctx context.Context,
        providerContext provider.Context,
        env map[string]string,
        loader AWSConfigLoader,
) (*aws.Config, error) <span class="cov3" title="2">{
        if loader == nil </span><span class="cov0" title="0">{
                loader = &amp;DefaultAWSConfigLoader{}
        }</span>

        <span class="cov3" title="2">opts := []func(*config.LoadOptions) error{}
        opts = append(opts, RegionOptions(providerContext)...)
        opts = append(opts, RetryConfigOptions(providerContext, env)...)
        opts = append(opts, CredentialOptions(providerContext)...)
        opts = append(opts, SharedEndpointOptions(providerContext)...)
        opts = append(opts, EC2MetadataServiceOptions(providerContext, env)...)

        certOpts, err := CertOptions(providerContext, env)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov3" title="2">opts = append(opts, certOpts...)

        opts = append(opts, HTTPClientOptions(providerContext)...)
        opts = append(opts, AssumeRoleOptions(providerContext)...)
        opts = append(opts, AssumeRoleWithWebIdentityOptions(providerContext)...)

        cfg, err := loader.LoadDefaultConfig(ctx, opts...)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return &amp;cfg, nil</span>
}

// RegionOptions returns the region options derived from the given provider context.
func RegionOptions(
        providerContext provider.Context,
) []func(*config.LoadOptions) error <span class="cov5" title="4">{
        opts := []func(*config.LoadOptions) error{}

        region, hasRegion := providerContext.ProviderConfigVariable("region")
        if hasRegion &amp;&amp; !core.IsScalarNil(region) </span><span class="cov3" title="2">{
                opts = append(opts, config.WithRegion(core.StringValueFromScalar(region)))
        }</span>

        <span class="cov5" title="4">return opts</span>
}

// RetryConfigOptions returns the retry config options derived from the
// given provider context and environment variables.
func RetryConfigOptions(
        providerContext provider.Context,
        env map[string]string,
) []func(*config.LoadOptions) error <span class="cov5" title="5">{
        opts := []func(*config.LoadOptions) error{}

        retryMode, hasRetryMode := getProviderConfigValueFallbackToEnv(
                providerContext,
                env,
                "retryMode",
                "AWS_RETRY_MODE",
        )
        if hasRetryMode &amp;&amp; !core.IsScalarNil(retryMode) </span><span class="cov3" title="2">{
                retryModeValue := core.StringValueFromScalar(retryMode)
                opts = append(opts, config.WithRetryMode(aws.RetryMode(retryModeValue)))
        }</span>

        <span class="cov5" title="5">maxRetries, hasMaxRetries := providerContext.ProviderConfigVariable("maxRetries")
        if hasMaxRetries &amp;&amp; !core.IsScalarNil(maxRetries) </span><span class="cov1" title="1">{
                maxRetriesValue := core.IntValueFromScalar(maxRetries)
                opts = append(opts, config.WithRetryMaxAttempts(maxRetriesValue))
        }</span>

        <span class="cov5" title="5">return opts</span>
}

// CredentialOptions returns the credential options derived from the given provider context.
func CredentialOptions(
        providerContext provider.Context,
) []func(*config.LoadOptions) error <span class="cov5" title="5">{
        opts := []func(*config.LoadOptions) error{}

        accessKeyID, hasAccessKeyID := providerContext.ProviderConfigVariable(
                "accessKeyId",
        )
        secretAccessKey, hasSecretAccessKey := providerContext.ProviderConfigVariable(
                "secretAccessKey",
        )
        sessionToken, _ := providerContext.ProviderConfigVariable(
                "sessionToken",
        )

        if hasAccessKeyID &amp;&amp; !core.IsScalarNil(accessKeyID) &amp;&amp;
                hasSecretAccessKey &amp;&amp; !core.IsScalarNil(secretAccessKey) </span><span class="cov1" title="1">{
                opts = append(opts, config.WithCredentialsProvider(
                        credentials.NewStaticCredentialsProvider(
                                core.StringValueFromScalar(accessKeyID),
                                core.StringValueFromScalar(secretAccessKey),
                                core.StringValueFromScalar(sessionToken),
                        ),
                ))
        }</span>

        <span class="cov5" title="5">sharedCredentialsFiles, hasSharedCredentialsFiles := providerContext.ProviderConfigVariable(
                "sharedCredentialsFiles",
        )
        if hasSharedCredentialsFiles &amp;&amp; !core.IsScalarNil(sharedCredentialsFiles) </span><span class="cov1" title="1">{
                credentialsFilesStr := core.StringValueFromScalar(sharedCredentialsFiles)
                credentialsFiles := strings.Split(credentialsFilesStr, ",")
                opts = append(opts, config.WithSharedCredentialsFiles(
                        credentialsFiles,
                ))
        }</span>

        <span class="cov5" title="5">sharedConfigFiles, hasSharedConfigFiles := providerContext.ProviderConfigVariable(
                "sharedConfigFiles",
        )
        if hasSharedConfigFiles &amp;&amp; !core.IsScalarNil(sharedConfigFiles) </span><span class="cov1" title="1">{
                configFilesStr := core.StringValueFromScalar(sharedConfigFiles)
                configFiles := strings.Split(configFilesStr, ",")
                opts = append(opts, config.WithSharedConfigFiles(
                        configFiles,
                ))
        }</span>

        <span class="cov5" title="5">profile, hasProfile := providerContext.ProviderConfigVariable(
                "profile",
        )
        if hasProfile &amp;&amp; !core.IsScalarNil(profile) </span><span class="cov1" title="1">{
                opts = append(opts, config.WithSharedConfigProfile(
                        core.StringValueFromScalar(profile),
                ))
        }</span>

        <span class="cov5" title="5">return opts</span>
}

// SharedEndpointOptions returns the shared endpoint options derived from the given provider context.
func SharedEndpointOptions(
        providerContext provider.Context,
) []func(*config.LoadOptions) error <span class="cov5" title="5">{
        opts := []func(*config.LoadOptions) error{}

        useFIPSEndpoint, hasUseFIPSEndpoint := providerContext.ProviderConfigVariable(
                "useFIPSEndpoint",
        )
        if hasUseFIPSEndpoint &amp;&amp; !core.IsScalarNil(useFIPSEndpoint) </span><span class="cov3" title="2">{
                useFIPSEndpointValue := core.BoolValueFromScalar(useFIPSEndpoint)
                fipsEndpointState := aws.FIPSEndpointStateDisabled
                if useFIPSEndpointValue </span><span class="cov1" title="1">{
                        fipsEndpointState = aws.FIPSEndpointStateEnabled
                }</span>
                <span class="cov3" title="2">opts = append(opts, config.WithUseFIPSEndpoint(fipsEndpointState))</span>
        }

        <span class="cov5" title="5">useDualStackEndpoint, hasUseDualStackEndpoint := providerContext.ProviderConfigVariable(
                "useDualStackEndpoint",
        )
        if hasUseDualStackEndpoint &amp;&amp; !core.IsScalarNil(useDualStackEndpoint) </span><span class="cov3" title="2">{
                useDualStackEndpointValue := core.BoolValueFromScalar(useDualStackEndpoint)
                dualStackEndpointState := aws.DualStackEndpointStateDisabled
                if useDualStackEndpointValue </span><span class="cov1" title="1">{
                        dualStackEndpointState = aws.DualStackEndpointStateEnabled
                }</span>
                <span class="cov3" title="2">opts = append(opts, config.WithUseDualStackEndpoint(dualStackEndpointState))</span>
        }

        <span class="cov5" title="5">return opts</span>
}

// CertOptions returns the cert options derived from the given provider context and environment variables.
func CertOptions(
        providerContext provider.Context,
        env map[string]string,
) ([]func(*config.LoadOptions) error, error) <span class="cov5" title="5">{
        opts := []func(*config.LoadOptions) error{}

        customCABundle, hasCustomCABundle := getProviderConfigValueFallbackToEnv(
                providerContext,
                env,
                "customCABundle",
                "AWS_CA_BUNDLE",
        )
        if hasCustomCABundle &amp;&amp; !core.IsScalarNil(customCABundle) </span><span class="cov1" title="1">{
                path := core.StringValueFromScalar(customCABundle)
                bundleData, err := os.ReadFile(path)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov1" title="1">opts = append(opts, config.WithCustomCABundle(
                        bytes.NewReader(bundleData),
                ))</span>
        }

        <span class="cov5" title="5">return opts, nil</span>
}

// HTTPClientOptions returns the http client options derived from the given provider context.
func HTTPClientOptions(
        providerContext provider.Context,
) []func(*config.LoadOptions) error <span class="cov5" title="4">{
        opts := []func(*config.LoadOptions) error{}

        insecureScalarValue, hasInsecure := providerContext.ProviderConfigVariable(
                "insecure",
        )
        insecure := core.BoolValueFromScalar(insecureScalarValue)

        httpProxyScalarValue, hasHTTPProxy := providerContext.ProviderConfigVariable(
                "httpProxy",
        )
        httpProxy := core.StringValueFromScalar(httpProxyScalarValue)

        httpsProxyScalarValue, hasHTTPSProxy := providerContext.ProviderConfigVariable(
                "httpsProxy",
        )
        httpsProxy := core.StringValueFromScalar(httpsProxyScalarValue)

        // The AWS SDK will automatically pick up the HTTP_PROXY and HTTPS_PROXY
        // environment variables, we only need to configure http proxies if defined
        // in the provider config.
        if (hasInsecure &amp;&amp; insecure) ||
                (hasHTTPProxy &amp;&amp; !core.IsScalarNil(httpProxyScalarValue)) ||
                (hasHTTPSProxy &amp;&amp; !core.IsScalarNil(httpsProxyScalarValue)) </span><span class="cov1" title="1">{
                customClient := awshttp.NewBuildableClient().WithTransportOptions(
                        func(t *http.Transport) </span><span class="cov1" title="1">{
                                if insecure </span><span class="cov0" title="0">{
                                        t.TLSClientConfig = &amp;tls.Config{
                                                InsecureSkipVerify: true,
                                        }
                                }</span>

                                <span class="cov1" title="1">finalProxyURL := strings.TrimSpace(httpProxy)
                                if finalProxyURL == "" </span><span class="cov0" title="0">{
                                        finalProxyURL = strings.TrimSpace(httpsProxy)
                                }</span>
                                <span class="cov1" title="1">if finalProxyURL != "" </span><span class="cov1" title="1">{
                                        parsedProxyURL, err := url.Parse(finalProxyURL)
                                        if err != nil </span><span class="cov0" title="0">{
                                                log.Fatalf("Failed to parse proxy URL: %v", err)
                                        }</span>

                                        <span class="cov1" title="1">t.Proxy = http.ProxyURL(parsedProxyURL)</span>
                                }
                        },
                )
                <span class="cov1" title="1">opts = append(opts, config.WithHTTPClient(customClient))</span>
        }

        <span class="cov5" title="4">return opts</span>
}

// EC2MetadataServiceOptions returns the ec2 metadata service options
// derived from the given provider context and environment variables.
func EC2MetadataServiceOptions(
        providerContext provider.Context,
        env map[string]string,
) []func(*config.LoadOptions) error <span class="cov5" title="5">{
        opts := []func(*config.LoadOptions) error{}

        ec2MetadataServiceEndpoint, hasEC2MetadataServiceEndpoint := getProviderConfigValueFallbackToEnv(
                providerContext,
                env,
                "ec2MetadataServiceEndpoint",
                "AWS_EC2_METADATA_SERVICE_ENDPOINT",
        )
        ec2MetadataServiceEndpointMode, hasEC2MetadataServiceEndpointMode := getProviderConfigValueFallbackToEnv(
                providerContext,
                env,
                "ec2MetadataServiceEndpointMode",
                "AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE",
        )

        if hasEC2MetadataServiceEndpoint &amp;&amp; !core.IsScalarNil(ec2MetadataServiceEndpoint) </span><span class="cov3" title="2">{
                opts = append(
                        opts,
                        config.WithEC2IMDSEndpoint(
                                core.StringValueFromScalar(ec2MetadataServiceEndpoint),
                        ),
                )
        }</span>

        <span class="cov5" title="5">if hasEC2MetadataServiceEndpointMode &amp;&amp; !core.IsScalarNil(ec2MetadataServiceEndpointMode) </span><span class="cov3" title="2">{
                opts = append(
                        opts,
                        config.WithEC2IMDSEndpointMode(
                                imds.EndpointModeState(
                                        imdsEndpointModeStateFromString(
                                                core.StringValueFromScalar(ec2MetadataServiceEndpointMode),
                                        ),
                                ),
                        ),
                )
        }</span>

        <span class="cov5" title="5">return opts</span>
}

func imdsEndpointModeStateFromString(s string) imds.EndpointModeState <span class="cov3" title="2">{
        switch strings.ToLower(s) </span>{
        case "ipv4":<span class="cov3" title="2">
                return imds.EndpointModeStateIPv4</span>
        case "ipv6":<span class="cov0" title="0">
                return imds.EndpointModeStateIPv6</span>
        default:<span class="cov0" title="0">
                return imds.EndpointModeStateUnset</span>
        }
}

// AssumeRoleOptions returns the assume role options derived from the given provider context.
func AssumeRoleOptions(
        providerContext provider.Context,
) []func(*config.LoadOptions) error <span class="cov5" title="4">{
        opts := []func(*config.LoadOptions) error{}

        assumeRoleARN, hasAssumeRoleARN := providerContext.ProviderConfigVariable(
                "assumeRole.roleArn",
        )

        assumeRoleExternalID, hasAssumeRoleExternalID := providerContext.ProviderConfigVariable(
                "assumeRole.externalId",
        )

        assumeRoleDuration, hasAssumeRoleDuration := providerContext.ProviderConfigVariable(
                "assumeRole.duration",
        )

        assumeRolePolicy, hasAssumeRolePolicy := providerContext.ProviderConfigVariable(
                "assumeRole.policy",
        )

        // Wrap in plugin config so we can use convenience helpers to get dynamic keys
        // based on prefix that emulate complex structures such as arrays.
        pluginConfig := core.PluginConfig(
                providerContext.ProviderConfigVariables(),
        )
        policyARNConfigValues := pluginConfig.SliceFromPrefix("assumeRole.policyArns")

        sessionName, hasSessionName := providerContext.ProviderConfigVariable(
                "assumeRole.sessionName",
        )

        sourceIdentity, hasSourceIdentity := providerContext.ProviderConfigVariable(
                "assumeRole.sourceIdentity",
        )

        tagValues := pluginConfig.MapFromPrefix("assumeRole.tags")

        transitiveTagKeys, hasTransitiveTagKeys := providerContext.ProviderConfigVariable(
                "assumeRole.transitiveTagKeys",
        )

        if hasAssumeRoleARN &amp;&amp; !core.IsScalarNil(assumeRoleARN) </span><span class="cov1" title="1">{
                config.WithAssumeRoleCredentialOptions(
                        func(o *stscreds.AssumeRoleOptions) </span><span class="cov0" title="0">{
                                o.RoleARN = core.StringValueFromScalar(assumeRoleARN)

                                if hasAssumeRoleExternalID &amp;&amp; !core.IsScalarNil(assumeRoleExternalID) </span><span class="cov0" title="0">{
                                        o.ExternalID = aws.String(core.StringValueFromScalar(assumeRoleExternalID))
                                }</span>

                                <span class="cov0" title="0">if hasAssumeRoleDuration &amp;&amp; !core.IsScalarNil(assumeRoleDuration) </span><span class="cov0" title="0">{
                                        // Validation in the provider config definition will make sure
                                        // that the duration is a valid duration string so it's safe to ignore
                                        // the error here.
                                        duration, _ := time.ParseDuration(core.StringValueFromScalar(assumeRoleDuration))
                                        o.Duration = duration
                                }</span>

                                <span class="cov0" title="0">if hasAssumeRolePolicy &amp;&amp; !core.IsScalarNil(assumeRolePolicy) </span><span class="cov0" title="0">{
                                        o.Policy = aws.String(core.StringValueFromScalar(assumeRolePolicy))
                                }</span>

                                <span class="cov0" title="0">if len(policyARNConfigValues) &gt; 0 </span><span class="cov0" title="0">{
                                        o.PolicyARNs = toSTSPolicyARNs(policyARNConfigValues)
                                }</span>

                                <span class="cov0" title="0">if hasSessionName &amp;&amp; !core.IsScalarNil(sessionName) </span><span class="cov0" title="0">{
                                        o.RoleSessionName = core.StringValueFromScalar(sessionName)
                                }</span>

                                <span class="cov0" title="0">if hasSourceIdentity &amp;&amp; !core.IsScalarNil(sourceIdentity) </span><span class="cov0" title="0">{
                                        o.SourceIdentity = aws.String(core.StringValueFromScalar(sourceIdentity))
                                }</span>

                                <span class="cov0" title="0">if len(tagValues) &gt; 0 </span><span class="cov0" title="0">{
                                        o.Tags = toSTSTags(tagValues)
                                }</span>

                                <span class="cov0" title="0">if hasTransitiveTagKeys &amp;&amp; !core.IsScalarNil(transitiveTagKeys) </span><span class="cov0" title="0">{
                                        o.TransitiveTagKeys = strings.Split(
                                                core.StringValueFromScalar(transitiveTagKeys),
                                                ",",
                                        )
                                }</span>
                        },
                )
        }

        <span class="cov5" title="4">return opts</span>
}

// AssumeRoleWithWebIdentityOptions returns the assume role with web identity
// options derived from the given provider context.
func AssumeRoleWithWebIdentityOptions(
        providerContext provider.Context,
) []func(*config.LoadOptions) error <span class="cov5" title="4">{
        opts := []func(*config.LoadOptions) error{}

        assumeRoleWebIdentityARN, hasAssumeRoleWebIdentityARN := providerContext.ProviderConfigVariable(
                "assumeRoleWithWebIdentity.roleArn",
        )

        assumeRoleWebIdentityToken, hasAssumeRoleWebIdentityToken := providerContext.ProviderConfigVariable(
                "assumeRoleWithWebIdentity.webIdentityToken",
        )

        assumeRoleWebIdentityTokenFile, hasAssumeRoleWebIdentityTokenFile := providerContext.ProviderConfigVariable(
                "assumeRoleWithWebIdentity.webIdentityTokenFile",
        )

        assumeRoleWebIdentityDuration, hasAssumeRoleWebIdentityDuration := providerContext.ProviderConfigVariable(
                "assumeRoleWithWebIdentity.duration",
        )

        assumeRoleWebIdentityPolicy, hasAssumeRoleWebIdentityPolicy := providerContext.ProviderConfigVariable(
                "assumeRoleWithWebIdentity.policy",
        )

        sessionName, hasSessionName := providerContext.ProviderConfigVariable(
                "assumeRoleWithWebIdentity.sessionName",
        )

        pluginConfig := core.PluginConfig(
                providerContext.ProviderConfigVariables(),
        )

        policyARNConfigValues := pluginConfig.SliceFromPrefix("assumeRoleWithWebIdentity.policyArns")

        if hasAssumeRoleWebIdentityARN &amp;&amp; !core.IsScalarNil(assumeRoleWebIdentityARN) </span><span class="cov1" title="1">{
                config.WithWebIdentityRoleCredentialOptions(
                        func(o *stscreds.WebIdentityRoleOptions) </span><span class="cov0" title="0">{
                                o.RoleARN = core.StringValueFromScalar(assumeRoleWebIdentityARN)

                                if hasAssumeRoleWebIdentityToken &amp;&amp; !core.IsScalarNil(assumeRoleWebIdentityToken) </span><span class="cov0" title="0">{
                                        o.TokenRetriever = staticTokenRetriever(
                                                core.StringValueFromScalar(assumeRoleWebIdentityToken),
                                        )
                                }</span>

                                <span class="cov0" title="0">if hasAssumeRoleWebIdentityTokenFile &amp;&amp; !core.IsScalarNil(assumeRoleWebIdentityTokenFile) </span><span class="cov0" title="0">{
                                        o.TokenRetriever = stscreds.IdentityTokenFile(
                                                core.StringValueFromScalar(assumeRoleWebIdentityTokenFile),
                                        )
                                }</span>

                                <span class="cov0" title="0">if hasAssumeRoleWebIdentityDuration &amp;&amp; !core.IsScalarNil(assumeRoleWebIdentityDuration) </span><span class="cov0" title="0">{
                                        duration, _ := time.ParseDuration(
                                                core.StringValueFromScalar(assumeRoleWebIdentityDuration),
                                        )
                                        o.Duration = duration
                                }</span>

                                <span class="cov0" title="0">if hasAssumeRoleWebIdentityPolicy &amp;&amp; !core.IsScalarNil(assumeRoleWebIdentityPolicy) </span><span class="cov0" title="0">{
                                        o.Policy = aws.String(core.StringValueFromScalar(assumeRoleWebIdentityPolicy))
                                }</span>

                                <span class="cov0" title="0">if len(policyARNConfigValues) &gt; 0 </span><span class="cov0" title="0">{
                                        o.PolicyARNs = toSTSPolicyARNs(policyARNConfigValues)
                                }</span>

                                <span class="cov0" title="0">if hasSessionName &amp;&amp; !core.IsScalarNil(sessionName) </span><span class="cov0" title="0">{
                                        o.RoleSessionName = core.StringValueFromScalar(sessionName)
                                }</span>
                        },
                )
        }

        <span class="cov5" title="4">return opts</span>
}

func getProviderConfigValueFallbackToEnv(
        providerContext provider.Context,
        env map[string]string,
        key string,
        envKey string,
) (*core.ScalarValue, bool) <span class="cov10" title="20">{
        providerConfigValue, hasProviderConfigValue := providerContext.ProviderConfigVariable(key)
        if hasProviderConfigValue &amp;&amp; !core.IsScalarNil(providerConfigValue) </span><span class="cov4" title="3">{
                return providerConfigValue, true
        }</span>

        <span class="cov9" title="17">envValue, hasEnvValue := env[envKey]
        if hasEnvValue </span><span class="cov5" title="4">{
                return core.ScalarFromString(envValue), true
        }</span>

        <span class="cov8" title="13">return nil, false</span>
}

func toSTSTags(tagValues map[string]*core.ScalarValue) []types.Tag <span class="cov0" title="0">{
        tags := make([]types.Tag, 0, len(tagValues))

        for key := range tagValues </span><span class="cov0" title="0">{
                tags = append(tags, types.Tag{
                        Key:   aws.String(key),
                        Value: aws.String(core.StringValueFromScalar(tagValues[key])),
                })
        }</span>

        <span class="cov0" title="0">return tags</span>
}

func toSTSPolicyARNs(policyARNConfigValues []*core.ScalarValue) []types.PolicyDescriptorType <span class="cov0" title="0">{
        policyARNs := make([]types.PolicyDescriptorType, 0, len(policyARNConfigValues))

        for _, policyARN := range policyARNConfigValues </span><span class="cov0" title="0">{
                policyARNs = append(policyARNs, types.PolicyDescriptorType{
                        Arn: aws.String(core.StringValueFromScalar(policyARN)),
                })
        }</span>

        <span class="cov0" title="0">return policyARNs</span>
}

type staticTokenRetriever string

func (s staticTokenRetriever) GetIdentityToken() ([]byte, error) <span class="cov0" title="0">{
        return []byte(s), nil
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package utils

import (
        "context"
        "strings"
        "sync"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/two-hundred/celerity/libs/blueprint/core"
        "github.com/two-hundred/celerity/libs/blueprint/provider"
        "github.com/two-hundred/celerity/libs/plugin-framework/sdk/pluginutils"
)

// AWSConfigCreator is a function that produces an AWS config
// from the given provider context and environment variables.
type AWSConfigCreator func(
        ctx context.Context,
        providerContext provider.Context,
        env map[string]string,
        loader AWSConfigLoader,
) (*aws.Config, error)

// AWSConfigStore is a store for AWS config that is used to derive and cache
// AWS config on a per-session basis.
type AWSConfigStore struct {
        // A copy of the environment variables for the current AWS provider process.
        env             map[string]string
        createAWSConfig AWSConfigCreator
        loader          AWSConfigLoader
        cache           map[string]*aws.Config
        mu              sync.RWMutex
}

// NewAWSConfigStore creates a new store for deriving and caching AWS config.
func NewAWSConfigStore(
        env []string,
        createAWSConfig AWSConfigCreator,
        loader AWSConfigLoader,
) *AWSConfigStore <span class="cov4" title="2">{
        envMap := envMapFromStrings(env)
        return &amp;AWSConfigStore{
                env:             envMap,
                createAWSConfig: createAWSConfig,
                cache:           make(map[string]*aws.Config),
                mu:              sync.RWMutex{},
        }
}</span>

// FromProviderContext creates configuration to be used to create AWS SDK clients.
func (s *AWSConfigStore) FromProviderContext(
        ctx context.Context,
        providerContext provider.Context,
) (*aws.Config, error) <span class="cov10" title="5">{
        // A session ID is passed from the client (e.g. Celerity CLI) to the host
        // and then to plugins through the context variables.
        // In the AWS provider, we use the session ID to cache AWS config
        // to avoid having to rebuild the config for each request to a plugin
        // action.
        sessionID, hasSessionID := getSessionID(ctx, providerContext)
        if hasSessionID </span><span class="cov7" title="3">{
                awsConfig, inCache := s.getFromCache(sessionID)
                if inCache </span><span class="cov1" title="1">{
                        return awsConfig, nil
                }</span>
        }

        <span class="cov8" title="4">awsConf, err := s.createAWSConfig(ctx, providerContext, s.env, s.loader)

        s.setInCache(sessionID, awsConf)
        return awsConf, err</span>
}

func (s *AWSConfigStore) getFromCache(sessionID string) (*aws.Config, bool) <span class="cov7" title="3">{
        s.mu.RLock()
        awsConfig, ok := s.cache[sessionID]
        s.mu.RUnlock()
        return awsConfig, ok
}</span>

func (s *AWSConfigStore) setInCache(sessionID string, awsConfig *aws.Config) <span class="cov8" title="4">{
        s.mu.Lock()
        s.cache[sessionID] = awsConfig
        s.mu.Unlock()
}</span>

func getSessionID(
        ctx context.Context,
        providerContext provider.Context,
) (string, bool) <span class="cov10" title="5">{
        // First, try the context variables as a part of the blueprint framework
        // provider context.
        sessionID, hasSessionID := providerContext.ContextVariable(pluginutils.SessionIDKey)
        if hasSessionID </span><span class="cov0" title="0">{
                return core.StringValueFromScalar(sessionID), true
        }</span>

        // If no session ID is found in the context variables, try the go context.
        <span class="cov10" title="5">goCtxSessionID, goCtxHasSessionId := ctx.Value(pluginutils.ContextSessionIDKey).(string)
        if goCtxHasSessionId </span><span class="cov7" title="3">{
                return goCtxSessionID, true
        }</span>

        <span class="cov4" title="2">return "", false</span>
}

func envMapFromStrings(env []string) map[string]string <span class="cov4" title="2">{
        envMap := make(map[string]string)
        for _, e := range env </span><span class="cov1" title="1">{
                parts := strings.SplitN(e, "=", 2)
                envMap[parts[0]] = parts[1]
        }</span>
        <span class="cov4" title="2">return envMap</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package utils

import "github.com/two-hundred/celerity/libs/blueprint/core"

// TagsToMappingNode converts a map of tags from an AWS service response
// to a MappingNode suitable for use in a resource spec.
func TagsToMappingNode(tags map[string]string) *core.MappingNode <span class="cov0" title="0">{
        tagSlice := make([]*core.MappingNode, 0, len(tags))

        for key, value := range tags </span><span class="cov0" title="0">{
                tagSlice = append(tagSlice, &amp;core.MappingNode{
                        Fields: map[string]*core.MappingNode{
                                "key":   core.MappingNodeFromString(key),
                                "value": core.MappingNodeFromString(value),
                        },
                })
        }</span>

        <span class="cov0" title="0">return &amp;core.MappingNode{
                Items: tagSlice,
        }</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package utils

import (
        "github.com/two-hundred/celerity/libs/blueprint/core"
        "github.com/two-hundred/celerity/libs/blueprint/source"
)

// GeneralDiagnosticRange returns a diagnostic range that can be used
// when the location of the diagnostic in a source config file or blueprint
// document is not known or is not applicable.
func GeneralDiagnosticRange() *core.DiagnosticRange <span class="cov0" title="0">{
        return &amp;core.DiagnosticRange{
                Start: &amp;source.Meta{
                        Position: source.Position{
                                Line:   1,
                                Column: 1,
                        },
                },
                End: &amp;source.Meta{
                        Position: source.Position{
                                Line:   1,
                                Column: 1,
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package utils

import (
        "fmt"
        "strings"

        "github.com/two-hundred/celerity/libs/blueprint/core"
        "github.com/two-hundred/celerity/libs/blueprint/provider"
)

// AWSServiceList returns a string of all the AWS services and their aliases.
func AWSServiceList() string <span class="cov0" title="0">{
        servicesSB := strings.Builder{}

        for service, aliases := range Services </span><span class="cov0" title="0">{
                servicesSB.WriteString(fmt.Sprintf("- %s", service))
                if len(aliases) &gt; 0 </span><span class="cov0" title="0">{
                        servicesSB.WriteString(
                                fmt.Sprintf(" (%s)\n", strings.Join(aliases, ", ")),
                        )
                }</span>
        }

        <span class="cov0" title="0">return servicesSB.String()</span>
}

// Services is a map of AWS services and their aliases.
var Services = map[string][]string{
        "account":  {},
        "lambda":   {},
        "dynamodb": {},
        "sqs":      {},
}

// GetEndpointFromProviderConfig returns the endpoint for a given service or one of its aliases.
func GetEndpointFromProviderConfig(
        providerContext provider.Context,
        service string,
        aliases []string,
) (*core.ScalarValue, bool) <span class="cov0" title="0">{
        endpoint, hasEndpoint := providerContext.ProviderConfigVariable(
                fmt.Sprintf("endpoint.%s", service),
        )
        if hasEndpoint &amp;&amp; !core.IsScalarNil(endpoint) </span><span class="cov0" title="0">{
                return endpoint, true
        }</span>

        <span class="cov0" title="0">for _, alias := range aliases </span><span class="cov0" title="0">{
                endpoint, hasEndpoint = providerContext.ProviderConfigVariable(
                        fmt.Sprintf("endpoint.%s", alias),
                )
                if hasEndpoint &amp;&amp; !core.IsScalarNil(endpoint) </span><span class="cov0" title="0">{
                        return endpoint, true
                }</span>
        }

        <span class="cov0" title="0">return nil, false</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
